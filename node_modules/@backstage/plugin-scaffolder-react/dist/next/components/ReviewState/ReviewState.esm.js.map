{"version":3,"file":"ReviewState.esm.js","sources":["../../../../src/next/components/ReviewState/ReviewState.tsx"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport React from 'react';\nimport { StructuredMetadataTable } from '@backstage/core-components';\nimport { JsonObject } from '@backstage/types';\nimport { Draft07 as JSONSchema } from 'json-schema-library';\nimport { ParsedTemplateSchema } from '../../hooks/useTemplateSchema';\n\n/**\n * The props for the {@link ReviewState} component.\n * @alpha\n */\nexport type ReviewStateProps = {\n  schemas: ParsedTemplateSchema[];\n  formState: JsonObject;\n};\n\n/**\n * The component used by the {@link Stepper} to render the review step.\n * @alpha\n */\nexport const ReviewState = (props: ReviewStateProps) => {\n  const reviewData = Object.fromEntries(\n    Object.entries(props.formState)\n      .map(([key, value]) => {\n        for (const step of props.schemas) {\n          const parsedSchema = new JSONSchema(step.mergedSchema);\n          const definitionInSchema = parsedSchema.getSchema({\n            pointer: `#/${key}`,\n            data: props.formState,\n          });\n\n          if (definitionInSchema) {\n            const backstageReviewOptions =\n              definitionInSchema['ui:backstage']?.review;\n\n            if (backstageReviewOptions) {\n              if (backstageReviewOptions.mask) {\n                return [key, backstageReviewOptions.mask];\n              }\n              if (backstageReviewOptions.show === false) {\n                return [];\n              }\n            }\n\n            if (definitionInSchema['ui:widget'] === 'password') {\n              return [key, '******'];\n            }\n\n            if (definitionInSchema.enum && definitionInSchema.enumNames) {\n              return [\n                key,\n                definitionInSchema.enumNames[\n                  definitionInSchema.enum.indexOf(value)\n                ] || value,\n              ];\n            }\n          }\n        }\n        return [key, value];\n      })\n      .filter(prop => prop.length > 0),\n  );\n  return <StructuredMetadataTable metadata={reviewData} />;\n};\n"],"names":["JSONSchema"],"mappings":";;;;AAkCa,MAAA,WAAA,GAAc,CAAC,KAA4B,KAAA;AACtD,EAAA,MAAM,aAAa,MAAO,CAAA,WAAA;AAAA,IACxB,MAAA,CAAO,OAAQ,CAAA,KAAA,CAAM,SAAS,CAAA,CAC3B,IAAI,CAAC,CAAC,GAAK,EAAA,KAAK,CAAM,KAAA;AACrB,MAAW,KAAA,MAAA,IAAA,IAAQ,MAAM,OAAS,EAAA;AAChC,QAAA,MAAM,YAAe,GAAA,IAAIA,OAAW,CAAA,IAAA,CAAK,YAAY,CAAA,CAAA;AACrD,QAAM,MAAA,kBAAA,GAAqB,aAAa,SAAU,CAAA;AAAA,UAChD,OAAA,EAAS,KAAK,GAAG,CAAA,CAAA;AAAA,UACjB,MAAM,KAAM,CAAA,SAAA;AAAA,SACb,CAAA,CAAA;AAED,QAAA,IAAI,kBAAoB,EAAA;AACtB,UAAM,MAAA,sBAAA,GACJ,kBAAmB,CAAA,cAAc,CAAG,EAAA,MAAA,CAAA;AAEtC,UAAA,IAAI,sBAAwB,EAAA;AAC1B,YAAA,IAAI,uBAAuB,IAAM,EAAA;AAC/B,cAAO,OAAA,CAAC,GAAK,EAAA,sBAAA,CAAuB,IAAI,CAAA,CAAA;AAAA,aAC1C;AACA,YAAI,IAAA,sBAAA,CAAuB,SAAS,KAAO,EAAA;AACzC,cAAA,OAAO,EAAC,CAAA;AAAA,aACV;AAAA,WACF;AAEA,UAAI,IAAA,kBAAA,CAAmB,WAAW,CAAA,KAAM,UAAY,EAAA;AAClD,YAAO,OAAA,CAAC,KAAK,QAAQ,CAAA,CAAA;AAAA,WACvB;AAEA,UAAI,IAAA,kBAAA,CAAmB,IAAQ,IAAA,kBAAA,CAAmB,SAAW,EAAA;AAC3D,YAAO,OAAA;AAAA,cACL,GAAA;AAAA,cACA,mBAAmB,SACjB,CAAA,kBAAA,CAAmB,KAAK,OAAQ,CAAA,KAAK,CACvC,CAAK,IAAA,KAAA;AAAA,aACP,CAAA;AAAA,WACF;AAAA,SACF;AAAA,OACF;AACA,MAAO,OAAA,CAAC,KAAK,KAAK,CAAA,CAAA;AAAA,KACnB,CACA,CAAA,MAAA,CAAO,CAAQ,IAAA,KAAA,IAAA,CAAK,SAAS,CAAC,CAAA;AAAA,GACnC,CAAA;AACA,EAAO,uBAAA,KAAA,CAAA,aAAA,CAAC,uBAAwB,EAAA,EAAA,QAAA,EAAU,UAAY,EAAA,CAAA,CAAA;AACxD;;;;"}