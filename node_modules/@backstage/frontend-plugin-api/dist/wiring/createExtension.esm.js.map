{"version":3,"file":"createExtension.esm.js","sources":["../../src/wiring/createExtension.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AppNode } from '../apis';\nimport { PortableSchema } from '../schema';\nimport { Expand } from '../types';\nimport { ExtensionDataRef } from './createExtensionDataRef';\nimport { ExtensionInput } from './createExtensionInput';\n\n/** @public */\nexport type AnyExtensionDataMap = {\n  [name in string]: ExtensionDataRef<unknown, { optional?: true }>;\n};\n\n/** @public */\nexport type AnyExtensionInputMap = {\n  [inputName in string]: ExtensionInput<\n    AnyExtensionDataMap,\n    { optional: boolean; singleton: boolean }\n  >;\n};\n\n/**\n * Converts an extension data map into the matching concrete data values type.\n * @public\n */\nexport type ExtensionDataValues<TExtensionData extends AnyExtensionDataMap> = {\n  [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {\n    optional: true;\n  }\n    ? never\n    : DataName]: TExtensionData[DataName]['T'];\n} & {\n  [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {\n    optional: true;\n  }\n    ? DataName\n    : never]?: TExtensionData[DataName]['T'];\n};\n\n/**\n * Convert a single extension input into a matching resolved input.\n * @public\n */\nexport type ResolvedExtensionInput<TExtensionData extends AnyExtensionDataMap> =\n  {\n    node: AppNode;\n    output: ExtensionDataValues<TExtensionData>;\n  };\n\n/**\n * Converts an extension input map into a matching collection of resolved inputs.\n * @public\n */\nexport type ResolvedExtensionInputs<\n  TInputs extends { [name in string]: ExtensionInput<any, any> },\n> = {\n  [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton']\n    ? Array<Expand<ResolvedExtensionInput<TInputs[InputName]['extensionData']>>>\n    : false extends TInputs[InputName]['config']['optional']\n    ? Expand<ResolvedExtensionInput<TInputs[InputName]['extensionData']>>\n    : Expand<\n        ResolvedExtensionInput<TInputs[InputName]['extensionData']> | undefined\n      >;\n};\n\n/** @public */\nexport interface CreateExtensionOptions<\n  TOutput extends AnyExtensionDataMap,\n  TInputs extends AnyExtensionInputMap,\n  TConfig,\n> {\n  kind?: string;\n  namespace?: string;\n  name?: string;\n  attachTo: { id: string; input: string };\n  disabled?: boolean;\n  inputs?: TInputs;\n  output: TOutput;\n  configSchema?: PortableSchema<TConfig>;\n  factory(options: {\n    node: AppNode;\n    config: TConfig;\n    inputs: Expand<ResolvedExtensionInputs<TInputs>>;\n  }): Expand<ExtensionDataValues<TOutput>>;\n}\n\n/** @public */\nexport interface ExtensionDefinition<TConfig> {\n  $$type: '@backstage/ExtensionDefinition';\n  readonly kind?: string;\n  readonly namespace?: string;\n  readonly name?: string;\n  readonly attachTo: { id: string; input: string };\n  readonly disabled: boolean;\n  readonly configSchema?: PortableSchema<TConfig>;\n}\n\n/** @internal */\nexport interface InternalExtensionDefinition<TConfig>\n  extends ExtensionDefinition<TConfig> {\n  readonly version: 'v1';\n  readonly inputs: AnyExtensionInputMap;\n  readonly output: AnyExtensionDataMap;\n  factory(options: {\n    node: AppNode;\n    config: TConfig;\n    inputs: ResolvedExtensionInputs<any>;\n  }): ExtensionDataValues<any>;\n}\n\n/** @internal */\nexport function toInternalExtensionDefinition<TConfig>(\n  overrides: ExtensionDefinition<TConfig>,\n): InternalExtensionDefinition<TConfig> {\n  const internal = overrides as InternalExtensionDefinition<TConfig>;\n  if (internal.$$type !== '@backstage/ExtensionDefinition') {\n    throw new Error(\n      `Invalid extension definition instance, bad type '${internal.$$type}'`,\n    );\n  }\n  if (internal.version !== 'v1') {\n    throw new Error(\n      `Invalid extension definition instance, bad version '${internal.version}'`,\n    );\n  }\n  return internal;\n}\n\n/** @public */\nexport function createExtension<\n  TOutput extends AnyExtensionDataMap,\n  TInputs extends AnyExtensionInputMap,\n  TConfig = never,\n>(\n  options: CreateExtensionOptions<TOutput, TInputs, TConfig>,\n): ExtensionDefinition<TConfig> {\n  return {\n    $$type: '@backstage/ExtensionDefinition',\n    version: 'v1',\n    kind: options.kind,\n    namespace: options.namespace,\n    name: options.name,\n    attachTo: options.attachTo,\n    disabled: options.disabled ?? false,\n    inputs: options.inputs ?? {},\n    output: options.output,\n    configSchema: options.configSchema,\n    factory({ inputs, ...rest }) {\n      // TODO: Simplify this, but TS wouldn't infer the input type for some reason\n      return options.factory({\n        inputs: inputs as Expand<ResolvedExtensionInputs<TInputs>>,\n        ...rest,\n      });\n    },\n    toString() {\n      const parts: string[] = [];\n      if (options.kind) {\n        parts.push(`kind=${options.kind}`);\n      }\n      if (options.namespace) {\n        parts.push(`namespace=${options.namespace}`);\n      }\n      if (options.name) {\n        parts.push(`name=${options.name}`);\n      }\n      parts.push(`attachTo=${options.attachTo.id}@${options.attachTo.input}`);\n      return `ExtensionDefinition{${parts.join(',')}}`;\n    },\n  } as InternalExtensionDefinition<TConfig>;\n}\n"],"names":[],"mappings":"AA6HO,SAAS,8BACd,SACsC,EAAA;AACtC,EAAA,MAAM,QAAW,GAAA,SAAA,CAAA;AACjB,EAAI,IAAA,QAAA,CAAS,WAAW,gCAAkC,EAAA;AACxD,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,iDAAA,EAAoD,SAAS,MAAM,CAAA,CAAA,CAAA;AAAA,KACrE,CAAA;AAAA,GACF;AACA,EAAI,IAAA,QAAA,CAAS,YAAY,IAAM,EAAA;AAC7B,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,oDAAA,EAAuD,SAAS,OAAO,CAAA,CAAA,CAAA;AAAA,KACzE,CAAA;AAAA,GACF;AACA,EAAO,OAAA,QAAA,CAAA;AACT,CAAA;AAGO,SAAS,gBAKd,OAC8B,EAAA;AAC9B,EAAO,OAAA;AAAA,IACL,MAAQ,EAAA,gCAAA;AAAA,IACR,OAAS,EAAA,IAAA;AAAA,IACT,MAAM,OAAQ,CAAA,IAAA;AAAA,IACd,WAAW,OAAQ,CAAA,SAAA;AAAA,IACnB,MAAM,OAAQ,CAAA,IAAA;AAAA,IACd,UAAU,OAAQ,CAAA,QAAA;AAAA,IAClB,QAAA,EAAU,QAAQ,QAAY,IAAA,KAAA;AAAA,IAC9B,MAAA,EAAQ,OAAQ,CAAA,MAAA,IAAU,EAAC;AAAA,IAC3B,QAAQ,OAAQ,CAAA,MAAA;AAAA,IAChB,cAAc,OAAQ,CAAA,YAAA;AAAA,IACtB,OAAQ,CAAA,EAAE,MAAQ,EAAA,GAAG,MAAQ,EAAA;AAE3B,MAAA,OAAO,QAAQ,OAAQ,CAAA;AAAA,QACrB,MAAA;AAAA,QACA,GAAG,IAAA;AAAA,OACJ,CAAA,CAAA;AAAA,KACH;AAAA,IACA,QAAW,GAAA;AACT,MAAA,MAAM,QAAkB,EAAC,CAAA;AACzB,MAAA,IAAI,QAAQ,IAAM,EAAA;AAChB,QAAA,KAAA,CAAM,IAAK,CAAA,CAAA,KAAA,EAAQ,OAAQ,CAAA,IAAI,CAAE,CAAA,CAAA,CAAA;AAAA,OACnC;AACA,MAAA,IAAI,QAAQ,SAAW,EAAA;AACrB,QAAA,KAAA,CAAM,IAAK,CAAA,CAAA,UAAA,EAAa,OAAQ,CAAA,SAAS,CAAE,CAAA,CAAA,CAAA;AAAA,OAC7C;AACA,MAAA,IAAI,QAAQ,IAAM,EAAA;AAChB,QAAA,KAAA,CAAM,IAAK,CAAA,CAAA,KAAA,EAAQ,OAAQ,CAAA,IAAI,CAAE,CAAA,CAAA,CAAA;AAAA,OACnC;AACA,MAAM,KAAA,CAAA,IAAA,CAAK,YAAY,OAAQ,CAAA,QAAA,CAAS,EAAE,CAAI,CAAA,EAAA,OAAA,CAAQ,QAAS,CAAA,KAAK,CAAE,CAAA,CAAA,CAAA;AACtE,MAAA,OAAO,CAAuB,oBAAA,EAAA,KAAA,CAAM,IAAK,CAAA,GAAG,CAAC,CAAA,CAAA,CAAA,CAAA;AAAA,KAC/C;AAAA,GACF,CAAA;AACF;;;;"}