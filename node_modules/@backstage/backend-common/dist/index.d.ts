/// <reference types="node" />
/// <reference types="webpack-env" />
import { Config, AppConfig } from '@backstage/config';
import * as _backstage_backend_plugin_api from '@backstage/backend-plugin-api';
import { LoggerService, CacheServiceOptions, CacheService, DatabaseService, UrlReaderService, UrlReaderServiceReadTreeResponse, UrlReaderServiceReadUrlOptions, UrlReaderServiceReadUrlResponse, UrlReaderServiceReadTreeOptions, UrlReaderServiceSearchOptions, UrlReaderServiceSearchResponse, TokenManagerService, DiscoveryService, CacheServiceSetOptions, LifecycleService, PluginMetadataService, isDatabaseConflictError as isDatabaseConflictError$1, resolvePackagePath as resolvePackagePath$1, resolveSafeChildPath as resolveSafeChildPath$1, isChildPath as isChildPath$1, ReadTreeOptions as ReadTreeOptions$1, ReadTreeResponse as ReadTreeResponse$1, ReadTreeResponseFile as ReadTreeResponseFile$1, ReadTreeResponseDirOptions as ReadTreeResponseDirOptions$1, ReadUrlOptions as ReadUrlOptions$1, ReadUrlResponse as ReadUrlResponse$1, SearchOptions as SearchOptions$1, SearchResponse as SearchResponse$1, SearchResponseFile as SearchResponseFile$1, ServiceRef, AuthService, HttpAuthService, UserInfoService, IdentityService } from '@backstage/backend-plugin-api';
import { AzureIntegration, AzureDevOpsCredentialsProvider, BitbucketCloudIntegration, BitbucketIntegration, BitbucketServerIntegration, GerritIntegration, GithubIntegration, GithubCredentialsProvider, GitLabIntegration, GiteaIntegration, HarnessIntegration, AwsS3Integration } from '@backstage/integration';
import { Readable, Writable } from 'stream';
import { AwsCredentialsManager } from '@backstage/integration-aws-node';
import * as winston from 'winston';
import { Logger } from 'winston';
import express, { Router, RequestHandler, ErrorRequestHandler } from 'express';
import { TransportStreamOptions } from 'winston-transport';
import { LoadConfigOptionsRemote } from '@backstage/config-loader';
import * as isomorphic_git from 'isomorphic-git';
import { AuthCallback, MergeResult, ReadCommitResult } from 'isomorphic-git';
import cors from 'cors';
import { Server } from 'http';
import Docker from 'dockerode';
import { KubeConfig, V1PodTemplateSpec } from '@kubernetes/client-node';

/**
 * Options given when constructing a {@link CacheManager}.
 *
 * @public
 */
type CacheManagerOptions$1 = {
    /**
     * An optional logger for use by the PluginCacheManager.
     */
    logger?: LoggerService;
    /**
     * An optional handler for connection errors emitted from the underlying data
     * store.
     */
    onError?: (err: Error) => void;
};
/**
 * @public
 */
interface PluginCacheManager$1 {
    getClient(options?: CacheServiceOptions): CacheService;
}

/**
 * Implements a Cache Manager which will automatically create new cache clients
 * for plugins when requested. All requested cache clients are created with the
 * connection details provided.
 *
 * @public
 */
declare class CacheManager$1 {
    /**
     * Keys represent supported `backend.cache.store` values, mapped to factories
     * that return Keyv instances appropriate to the store.
     */
    private readonly storeFactories;
    private readonly logger?;
    private readonly store;
    private readonly connection;
    private readonly useRedisSets;
    private readonly errorHandler;
    private readonly defaultTtl?;
    /**
     * Creates a new {@link CacheManager} instance by reading from the `backend`
     * config section, specifically the `.cache` key.
     *
     * @param config - The loaded application configuration.
     */
    static fromConfig(config: Config, options?: CacheManagerOptions$1): CacheManager$1;
    /**
     * Generates a PluginCacheManager for consumption by plugins.
     *
     * @param pluginId - The plugin that the cache manager should be created for.
     *        Plugin names should be unique.
     */
    forPlugin(pluginId: string): PluginCacheManager$1;
    private getClientWithTtl;
    private createRedisStoreFactory;
    private createMemcacheStoreFactory;
    private createMemoryStoreFactory;
}

/**
 * Creation options for {@link DatabaseManager}.
 *
 * @public
 */
type DatabaseManagerOptions$1 = {
    migrations?: DatabaseService['migrations'];
    logger?: LoggerService;
};
/**
 * An interface that represents the legacy global DatabaseManager implementation.
 * @public
 */
type LegacyRootDatabaseService$1 = {
    forPlugin(pluginId: string): DatabaseService;
};
/**
 * Helper for deleting databases.
 *
 * @public
 * @deprecated Will be removed in a future release.
 */
declare function dropDatabase$1(dbConfig: Config, ...databaseNames: string[]): Promise<void>;

/**
 * A predicate that decides whether a specific {@link @backstage/backend-plugin-api#UrlReaderService} can handle a
 * given URL.
 *
 * @public
 */
type UrlReaderPredicateTuple$1 = {
    predicate: (url: URL) => boolean;
    reader: UrlReaderService;
};
/**
 * A factory function that can read config to construct zero or more
 * {@link @backstage/backend-plugin-api#UrlReaderService}s along with a predicate for when it should be used.
 *
 * @public
 */
type ReaderFactory$1 = (options: {
    config: Config;
    logger: LoggerService;
    treeResponseFactory: ReadTreeResponseFactory$1;
}) => UrlReaderPredicateTuple$1[];
/**
 * An options object for {@link ReadUrlResponseFactory} factory methods.
 *
 * @public
 */
type ReadUrlResponseFactoryFromStreamOptions$1 = {
    etag?: string;
    lastModifiedAt?: Date;
};
/**
 * Options that control execution of {@link ReadTreeResponseFactory} methods.
 *
 * @public
 */
type ReadTreeResponseFactoryOptions$1 = {
    stream: Readable;
    subpath?: string;
    etag: string;
    filter?: (path: string, info?: {
        size: number;
    }) => boolean;
};
/**
 * Options that control {@link ReadTreeResponseFactory.fromReadableArray}
 * execution.
 *
 * @public
 */
type FromReadableArrayOptions$1 = Array<{
    /**
     * The raw data itself.
     */
    data: Readable;
    /**
     * The filepath of the data.
     */
    path: string;
    /**
     * Last modified date of the file contents.
     */
    lastModifiedAt?: Date;
}>;
/**
 * A factory for response factories that handle the unpacking and inspection of
 * complex responses such as archive data.
 *
 * @public
 */
interface ReadTreeResponseFactory$1 {
    fromTarArchive(options: ReadTreeResponseFactoryOptions$1 & {
        /**
         * Strip the first parent directory of a tar archive.
         * Defaults to true.
         */
        stripFirstDirectory?: boolean;
    }): Promise<UrlReaderServiceReadTreeResponse>;
    fromZipArchive(options: ReadTreeResponseFactoryOptions$1): Promise<UrlReaderServiceReadTreeResponse>;
    fromReadableArray(options: FromReadableArrayOptions$1): Promise<UrlReaderServiceReadTreeResponse>;
}

/**
 * Implements a {@link @backstage/backend-plugin-api#UrlReaderService} for Azure repos.
 *
 * @public
 */
declare class AzureUrlReader$1 implements UrlReaderService {
    private readonly integration;
    private readonly deps;
    static factory: ReaderFactory$1;
    constructor(integration: AzureIntegration, deps: {
        treeResponseFactory: ReadTreeResponseFactory$1;
        credentialsProvider: AzureDevOpsCredentialsProvider;
    });
    read(url: string): Promise<Buffer>;
    readUrl(url: string, options?: UrlReaderServiceReadUrlOptions): Promise<UrlReaderServiceReadUrlResponse>;
    readTree(url: string, options?: UrlReaderServiceReadTreeOptions): Promise<UrlReaderServiceReadTreeResponse>;
    search(url: string, options?: UrlReaderServiceSearchOptions): Promise<UrlReaderServiceSearchResponse>;
    toString(): string;
}

/**
 * Implements a {@link @backstage/backend-plugin-api#UrlReaderService} for files from Bitbucket Cloud.
 *
 * @public
 */
declare class BitbucketCloudUrlReader$1 implements UrlReaderService {
    private readonly integration;
    private readonly deps;
    static factory: ReaderFactory$1;
    constructor(integration: BitbucketCloudIntegration, deps: {
        treeResponseFactory: ReadTreeResponseFactory$1;
    });
    read(url: string): Promise<Buffer>;
    readUrl(url: string, options?: UrlReaderServiceReadUrlOptions): Promise<UrlReaderServiceReadUrlResponse>;
    readTree(url: string, options?: UrlReaderServiceReadTreeOptions): Promise<UrlReaderServiceReadTreeResponse>;
    search(url: string, options?: UrlReaderServiceSearchOptions): Promise<UrlReaderServiceSearchResponse>;
    toString(): string;
    private getLastCommitShortHash;
}

/**
 * Implements a {@link @backstage/backend-plugin-api#UrlReaderService} for files from Bitbucket v1 and v2 APIs, such
 * as the one exposed by Bitbucket Cloud itself.
 *
 * @public
 * @deprecated in favor of BitbucketCloudUrlReader and BitbucketServerUrlReader
 */
declare class BitbucketUrlReader$1 implements UrlReaderService {
    private readonly integration;
    private readonly deps;
    static factory: ReaderFactory$1;
    constructor(integration: BitbucketIntegration, logger: LoggerService, deps: {
        treeResponseFactory: ReadTreeResponseFactory$1;
    });
    read(url: string): Promise<Buffer>;
    readUrl(url: string, options?: UrlReaderServiceReadUrlOptions): Promise<UrlReaderServiceReadUrlResponse>;
    readTree(url: string, options?: UrlReaderServiceReadTreeOptions): Promise<UrlReaderServiceReadTreeResponse>;
    search(url: string, options?: UrlReaderServiceSearchOptions): Promise<UrlReaderServiceSearchResponse>;
    toString(): string;
    private getLastCommitShortHash;
}

/**
 * Implements a {@link @backstage/backend-plugin-api#UrlReaderService} for files from Bitbucket Server APIs.
 *
 * @public
 */
declare class BitbucketServerUrlReader$1 implements UrlReaderService {
    private readonly integration;
    private readonly deps;
    static factory: ReaderFactory$1;
    constructor(integration: BitbucketServerIntegration, deps: {
        treeResponseFactory: ReadTreeResponseFactory$1;
    });
    read(url: string): Promise<Buffer>;
    readUrl(url: string, options?: UrlReaderServiceReadUrlOptions): Promise<UrlReaderServiceReadUrlResponse>;
    readTree(url: string, options?: UrlReaderServiceReadTreeOptions): Promise<UrlReaderServiceReadTreeResponse>;
    search(url: string, options?: UrlReaderServiceSearchOptions): Promise<UrlReaderServiceSearchResponse>;
    toString(): string;
    private getLastCommitShortHash;
}

/**
 * Implements a {@link @backstage/backend-plugin-api#UrlReaderService} for files in Gerrit.
 *
 * @remarks
 * To be able to link to Git contents for Gerrit providers in a user friendly
 * way we are depending on that there is a Gitiles installation somewhere
 * that we can link to. It is perfectly possible to integrate Gerrit with
 * Backstage without Gitiles since all API calls goes directly to Gerrit.
 * However if Gitiles is configured, readTree will use it to fetch
 * an archive instead of cloning the repository.
 *
 * The "host" variable in the config is the Gerrit host. The address where
 * Gitiles is installed may be on the same host but it could be on a
 * separate host. For example a Gerrit instance could be hosted on
 * "gerrit-review.company.com" but the repos could be browsable on a separate
 * host, e.g. "gerrit.company.com" and the human readable URL would then
 * not point to the API host.
 *
 * @public
 */
declare class GerritUrlReader$1 implements UrlReaderService {
    private readonly integration;
    private readonly deps;
    static factory: ReaderFactory$1;
    constructor(integration: GerritIntegration, deps: {
        treeResponseFactory: ReadTreeResponseFactory$1;
    });
    read(url: string): Promise<Buffer>;
    readUrl(url: string, options?: UrlReaderServiceReadUrlOptions): Promise<UrlReaderServiceReadUrlResponse>;
    readTree(url: string, options?: UrlReaderServiceReadTreeOptions): Promise<UrlReaderServiceReadTreeResponse>;
    search(): Promise<UrlReaderServiceSearchResponse>;
    toString(): string;
    private readTreeFromGitiles;
}

/**
 * Implements a {@link @backstage/backend-plugin-api#UrlReaderService} for files through the GitHub v3 APIs, such as
 * the one exposed by GitHub itself.
 *
 * @public
 */
declare class GithubUrlReader$1 implements UrlReaderService {
    private readonly integration;
    private readonly deps;
    static factory: ReaderFactory$1;
    constructor(integration: GithubIntegration, deps: {
        treeResponseFactory: ReadTreeResponseFactory$1;
        credentialsProvider: GithubCredentialsProvider;
    });
    read(url: string): Promise<Buffer>;
    private getCredentials;
    readUrl(url: string, options?: UrlReaderServiceReadUrlOptions): Promise<UrlReaderServiceReadUrlResponse>;
    readTree(url: string, options?: UrlReaderServiceReadTreeOptions): Promise<UrlReaderServiceReadTreeResponse>;
    search(url: string, options?: UrlReaderServiceSearchOptions): Promise<UrlReaderServiceSearchResponse>;
    toString(): string;
    private doReadTree;
    private doSearch;
    private getRepoDetails;
    private getDefaultBranch;
    private fetchResponse;
    private fetchJson;
}

/**
 * Implements a {@link @backstage/backend-plugin-api#UrlReaderService} for files on GitLab.
 *
 * @public
 */
declare class GitlabUrlReader$1 implements UrlReaderService {
    private readonly integration;
    private readonly deps;
    static factory: ReaderFactory$1;
    constructor(integration: GitLabIntegration, deps: {
        treeResponseFactory: ReadTreeResponseFactory$1;
    });
    read(url: string): Promise<Buffer>;
    readUrl(url: string, options?: UrlReaderServiceReadUrlOptions): Promise<UrlReaderServiceReadUrlResponse>;
    readTree(url: string, options?: UrlReaderServiceReadTreeOptions): Promise<UrlReaderServiceReadTreeResponse>;
    search(url: string, options?: UrlReaderServiceSearchOptions): Promise<UrlReaderServiceSearchResponse>;
    /**
     * This function splits the input globPattern string into segments using the  path separator /. It then iterates over
     * the segments from the end of the array towards the beginning, checking if the concatenated string up to that
     * segment matches the original globPattern using the minimatch function. If a match is found, it continues iterating.
     * If no match is found, it returns the concatenated string up to the current segment, which is the static part of the
     * glob pattern.
     *
     * E.g. `catalog/foo/*.yaml` will return `catalog/foo`.
     *
     * @param globPattern the glob pattern
     * @private
     */
    private getStaticPart;
    toString(): string;
    private getGitlabFetchUrl;
    private getGitlabArtifactFetchUrl;
    private resolveProjectToId;
}

/**
 * Implements a {@link @backstage/backend-plugin-api#UrlReaderService} for the Gitea v1 api.
 *
 * @public
 */
declare class GiteaUrlReader$1 implements UrlReaderService {
    private readonly integration;
    private readonly deps;
    static factory: ReaderFactory$1;
    constructor(integration: GiteaIntegration, deps: {
        treeResponseFactory: ReadTreeResponseFactory$1;
    });
    read(url: string): Promise<Buffer>;
    readUrl(url: string, options?: UrlReaderServiceReadUrlOptions): Promise<UrlReaderServiceReadUrlResponse>;
    readTree(url: string, options?: UrlReaderServiceReadTreeOptions): Promise<UrlReaderServiceReadTreeResponse>;
    search(): Promise<UrlReaderServiceSearchResponse>;
    toString(): string;
    private getLastCommitHash;
}

/**
 * Implements a {@link @backstage/backend-plugin-api#UrlReaderService} for the Harness code v1 api.
 *
 *
 * @public
 */
declare class HarnessUrlReader$1 implements UrlReaderService {
    private readonly integration;
    private readonly deps;
    static factory: ReaderFactory$1;
    constructor(integration: HarnessIntegration, deps: {
        treeResponseFactory: ReadTreeResponseFactory$1;
    });
    read(url: string): Promise<Buffer>;
    readUrl(url: string, options?: UrlReaderServiceReadUrlOptions): Promise<UrlReaderServiceReadUrlResponse>;
    readTree(url: string, options?: UrlReaderServiceReadTreeOptions): Promise<UrlReaderServiceReadTreeResponse>;
    search(): Promise<UrlReaderServiceSearchResponse>;
    toString(): string;
    private getLastCommitHash;
}

/**
 * Implements a {@link @backstage/backend-plugin-api#UrlReaderService} for AWS S3 buckets.
 *
 * @public
 */
declare class AwsS3UrlReader$1 implements UrlReaderService {
    private readonly credsManager;
    private readonly integration;
    private readonly deps;
    static factory: ReaderFactory$1;
    constructor(credsManager: AwsCredentialsManager, integration: AwsS3Integration, deps: {
        treeResponseFactory: ReadTreeResponseFactory$1;
    });
    /**
     * If accessKeyId and secretAccessKey are missing, the standard credentials provider chain will be used:
     * https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/auth/DefaultAWSCredentialsProviderChain.html
     */
    private static buildStaticCredentials;
    private static buildCredentials;
    private buildS3Client;
    private retrieveS3ObjectData;
    read(url: string): Promise<Buffer>;
    readUrl(url: string, options?: UrlReaderServiceReadUrlOptions): Promise<UrlReaderServiceReadUrlResponse>;
    readTree(url: string, options?: UrlReaderServiceReadTreeOptions): Promise<UrlReaderServiceReadTreeResponse>;
    search(): Promise<UrlReaderServiceSearchResponse>;
    toString(): string;
}

/**
 * A {@link @backstage/backend-plugin-api#UrlReaderService} that does a plain fetch of the URL.
 *
 * @public
 */
declare class FetchUrlReader$1 implements UrlReaderService {
    /**
     * The factory creates a single reader that will be used for reading any URL that's listed
     * in configuration at `backend.reading.allow`. The allow list contains a list of objects describing
     * targets to allow, containing the following fields:
     *
     * `host`:
     *   Either full hostnames to match, or subdomain wildcard matchers with a leading '*'.
     *   For example 'example.com' and '*.example.com' are valid values, 'prod.*.example.com' is not.
     *
     * `paths`:
     *   An optional list of paths which are allowed. If the list is omitted all paths are allowed.
     */
    static factory: ReaderFactory$1;
    read(url: string): Promise<Buffer>;
    readUrl(url: string, options?: UrlReaderServiceReadUrlOptions): Promise<UrlReaderServiceReadUrlResponse>;
    readTree(): Promise<UrlReaderServiceReadTreeResponse>;
    search(): Promise<UrlReaderServiceSearchResponse>;
    toString(): string;
}

/**
 * Creation options for {@link @backstage/backend-plugin-api#UrlReaderService}.
 *
 * @public
 */
type UrlReadersOptions$1 = {
    /** Root config object */
    config: Config;
    /** Logger used by all the readers */
    logger: LoggerService;
    /** A list of factories used to construct individual readers that match on URLs */
    factories?: ReaderFactory$1[];
};
/**
 * Helps construct {@link @backstage/backend-plugin-api#UrlReaderService}s.
 *
 * @public
 */
declare class UrlReaders$1 {
    /**
     * Creates a custom {@link @backstage/backend-plugin-api#UrlReaderService} wrapper for your own set of factories.
     */
    static create(options: UrlReadersOptions$1): UrlReaderService;
    /**
     * Creates a {@link @backstage/backend-plugin-api#UrlReaderService} wrapper that includes all the default factories
     * from this package.
     *
     * Any additional factories passed will be loaded before the default ones.
     */
    static default(options: UrlReadersOptions$1): UrlReaderService;
}

/**
 * Utility class for UrlReader implementations to create valid ReadUrlResponse
 * instances from common response primitives.
 *
 * @public
 */
declare class ReadUrlResponseFactory$1 {
    /**
     * Resolves a ReadUrlResponse from a Readable stream.
     */
    static fromReadable(stream: Readable, options?: ReadUrlResponseFactoryFromStreamOptions$1): Promise<UrlReaderServiceReadUrlResponse>;
    /**
     * Resolves a ReadUrlResponse from an old-style NodeJS.ReadableStream.
     */
    static fromNodeJSReadable(oldStyleStream: NodeJS.ReadableStream, options?: ReadUrlResponseFactoryFromStreamOptions$1): Promise<UrlReaderServiceReadUrlResponse>;
}

/**
 * useHotCleanup allows cleanup of ongoing effects when a module is
 * hot-reloaded during development. The cleanup function will be called
 * whenever the module itself or any of its parent modules is hot-reloaded.
 *
 * Useful for cleaning intervals, timers, requests etc
 *
 * @public
 * @deprecated Hot module reloading is no longer supported for backends.
 * @example
 * ```ts
 * const intervalId = setInterval(doStuff, 1000);
 * useHotCleanup(module, () => clearInterval(intervalId));
 * ```
 * @param _module - Reference to the current module where you invoke the fn
 * @param cancelEffect - Fn that cleans up the ongoing effects
 */
declare function useHotCleanup(_module: NodeModule, cancelEffect: () => void): void;
/**
 * Memoizes a generated value across hot-module reloads. This is useful for
 * stateful parts of the backend, e.g. to retain a database.
 *
 * @public
 * @deprecated Hot module reloading is no longer supported for backends.
 * @example
 * ```ts
 * const db = useHotMemoize(module, () => createDB(dbParams));
 * ```
 *
 * **NOTE:** Do not use inside conditionals or loops,
 * same rules as for hooks apply (https://reactjs.org/docs/hooks-rules.html)
 *
 * @param _module - Reference to the current module where you invoke the fn
 * @param valueFactory - Fn that returns the value you want to memoize
 */
declare function useHotMemoize<T>(_module: NodeModule, valueFactory: () => T): T;

/**
 * Load configuration for a Backend.
 *
 * This function should only be called once, during the initialization of the backend.
 *
 * @public
 * @deprecated Use {@link @backstage/backend-app-api#loadBackendConfig} instead.
 */
declare function loadBackendConfig(options: {
    logger: LoggerService;
    remote?: LoadConfigOptionsRemote;
    additionalConfigs?: AppConfig[];
    argv: string[];
    watch?: boolean;
}): Promise<Config>;

/**
 * Configure static credential for authentication
 * @public
 * @deprecated This type is deprecated and will be removed in a future release, see https://github.com/backstage/backstage/issues/24493.
 */
type StaticAuthOptions = {
    username?: string;
    password?: string;
    token?: string;
    logger?: LoggerService;
};
/**
 * Configure an authentication callback that can provide credentials on demand
 * @public
 * @deprecated This type is deprecated and will be removed in a future release, see https://github.com/backstage/backstage/issues/24493.
 */
type AuthCallbackOptions = {
    onAuth: AuthCallback;
    logger?: LoggerService;
};
/**
 * A convenience wrapper around the `isomorphic-git` library.
 * @public
 * @deprecated This class is deprecated and will be removed in a future release, see https://github.com/backstage/backstage/issues/24493.
 */
declare class Git {
    private readonly config;
    private readonly headers;
    private constructor();
    add(options: {
        dir: string;
        filepath: string;
    }): Promise<void>;
    addRemote(options: {
        dir: string;
        remote: string;
        url: string;
        force?: boolean;
    }): Promise<void>;
    deleteRemote(options: {
        dir: string;
        remote: string;
    }): Promise<void>;
    checkout(options: {
        dir: string;
        ref: string;
    }): Promise<void>;
    branch(options: {
        dir: string;
        ref: string;
    }): Promise<void>;
    commit(options: {
        dir: string;
        message: string;
        author: {
            name: string;
            email: string;
        };
        committer: {
            name: string;
            email: string;
        };
    }): Promise<string>;
    /** https://isomorphic-git.org/docs/en/clone */
    clone(options: {
        url: string;
        dir: string;
        ref?: string;
        depth?: number;
        noCheckout?: boolean;
    }): Promise<void>;
    /** https://isomorphic-git.org/docs/en/currentBranch */
    currentBranch(options: {
        dir: string;
        fullName?: boolean;
    }): Promise<string | undefined>;
    /** https://isomorphic-git.org/docs/en/fetch */
    fetch(options: {
        dir: string;
        remote?: string;
        tags?: boolean;
    }): Promise<void>;
    init(options: {
        dir: string;
        defaultBranch?: string;
    }): Promise<void>;
    /** https://isomorphic-git.org/docs/en/merge */
    merge(options: {
        dir: string;
        theirs: string;
        ours?: string;
        author: {
            name: string;
            email: string;
        };
        committer: {
            name: string;
            email: string;
        };
    }): Promise<MergeResult>;
    push(options: {
        dir: string;
        remote: string;
        remoteRef?: string;
        force?: boolean;
    }): Promise<isomorphic_git.PushResult>;
    /** https://isomorphic-git.org/docs/en/readCommit */
    readCommit(options: {
        dir: string;
        sha: string;
    }): Promise<ReadCommitResult>;
    /** https://isomorphic-git.org/docs/en/remove */
    remove(options: {
        dir: string;
        filepath: string;
    }): Promise<void>;
    /** https://isomorphic-git.org/docs/en/resolveRef */
    resolveRef(options: {
        dir: string;
        ref: string;
    }): Promise<string>;
    /** https://isomorphic-git.org/docs/en/log */
    log(options: {
        dir: string;
        ref?: string;
    }): Promise<ReadCommitResult[]>;
    private onAuth;
    private onProgressHandler;
    static fromAuth: (options: StaticAuthOptions | AuthCallbackOptions) => Git;
}

/**
 * @public
 * @deprecated Please {@link https://backstage.io/docs/tutorials/auth-service-migration | migrate} to the new `coreServices.auth`, `coreServices.httpAuth`, and `coreServices.userInfo` services as needed instead.
 */
type TokenManager = TokenManagerService;

/**
 * Options for {@link ServerTokenManager}.
 *
 * @public
 * @deprecated Please {@link https://backstage.io/docs/tutorials/auth-service-migration | migrate} to the new `coreServices.auth`, `coreServices.httpAuth`, and `coreServices.userInfo` services as needed instead.
 */
interface ServerTokenManagerOptions {
    /**
     * The logger to use.
     */
    logger: LoggerService;
    /**
     * Whether to disable the token manager if no keys are configured.
     */
    allowDisabledTokenManager?: boolean;
}
/**
 * Creates and validates tokens for use during service-to-service
 * authentication.
 *
 * @public
 * @deprecated Please {@link https://backstage.io/docs/tutorials/auth-service-migration | migrate} to the new `coreServices.auth`, `coreServices.httpAuth`, and `coreServices.userInfo` services as needed instead.
 */
declare class ServerTokenManager implements TokenManager {
    private readonly options;
    private readonly verificationKeys;
    private signingKey;
    private privateKeyPromise;
    private currentTokenPromise;
    /**
     * Creates a token manager that issues static fake tokens and never fails
     * authentication. This can be useful for testing.
     */
    static noop(): TokenManager;
    static fromConfig(config: Config, options: ServerTokenManagerOptions): TokenManager;
    private constructor();
    private generateKeys;
    getToken(): Promise<{
        token: string;
    }>;
    authenticate(token: string): Promise<void>;
}

/**
 * A logger that just throws away all messages.
 *
 * @public
 * @deprecated As we are going to deprecate the legacy backend, this function will be removed in the future.
 * If you need to mock the root logger in the new system, please use `mockServices.logger.mock()` from `@backstage/test-utils` instead.
 */
declare function getVoidLogger(): winston.Logger;
/**
 * Gets the current root logger.
 *
 * @public
 * @deprecated As we are going to deprecate the legacy backend, this function will be removed in the future.
 * If you need to get the root logger in the new system, please check out this documentation:
 * https://backstage.io/docs/backend-system/core-services/logger
 */
declare function getRootLogger(): winston.Logger;
/**
 * Sets a completely custom default "root" logger.
 *
 * @remarks
 *
 * This is the logger instance that will be the foundation for all other logger
 * instances passed to plugins etc, in a given backend.
 *
 * Only use this if you absolutely need to make a completely custom logger.
 * Normally if you want to make light adaptations to the default logger
 * behavior, you would instead call {@link createRootLogger}.
 *
 * @public
 * @deprecated As we are going to deprecate the legacy backend, this function will be removed in the future.
 * If you need to set the root logger in the new system, please check out this documentation:
 * https://backstage.io/docs/backend-system/core-services/logger
 */
declare function setRootLogger(newLogger: winston.Logger): void;

/**
 * A winston formatting function that finds occurrences of filteredKeys
 * and replaces them with the corresponding identifier.
 *
 * @public
 * @deprecated This utility is being deprecated along with the {@link https://github.com/backstage/backstage/issues/24493 |legacy backend system}.
 * Migrate your {@link https://backstage.io/docs/backend-system/building-backends/migrating | backend} and {@link https://backstage.io/docs/backend-system/building-plugins-and-modules/migrating | plugin} to the new system and use the {@link https://github.com/backstage/backstage/pull/24730 | RedactionsService} for customization instead.
 */
declare function redactWinstonLogLine(info: winston.Logform.TransformableInfo): winston.Logform.TransformableInfo;
/**
 * Creates a pretty printed winston log formatter.
 *
 * @public
 * @deprecated As we are going to deprecate the legacy backend, this formatter utility will be removed in the future.
 * If you need to format logs in the new system, please use the `WinstonLogger.colorFormat()` from `@backstage/backend-app-api` instead.
 */
declare const coloredFormat: winston.Logform.Format;
/**
 * Creates a default "root" logger. This also calls {@link setRootLogger} under
 * the hood.
 *
 * @remarks
 *
 * This is the logger instance that will be the foundation for all other logger
 * instances passed to plugins etc, in a given backend.
 *
 * @public
 * @deprecated As we are going to deprecate the legacy backend, this function will be removed in the future.
 * If you need to create the root logger in the new system, please check out this documentation:
 * https://backstage.io/docs/backend-system/core-services/logger
 */
declare function createRootLogger(options?: winston.LoggerOptions, env?: NodeJS.ProcessEnv): winston.Logger;

/**
 * A helper for building backend service instances.
 *
 * @public
 * @deprecated This type is being deprecated along with the {@link @backstage/backend-common#createServiceBuilder} function.
 */
type ServiceBuilder = {
    /**
     * Sets the service parameters based on configuration.
     *
     * @param config - The configuration to read
     */
    loadConfig(config: Config): ServiceBuilder;
    /**
     * Sets the port to listen on.
     *
     * If no port is specified, the service will first look for an environment
     * variable named PORT and use that if present, otherwise it picks a default
     * port (7007).
     *
     * @param port - The port to listen on
     */
    setPort(port: number): ServiceBuilder;
    /**
     * Sets the host to listen on.
     *
     * '' is express default, which listens to all interfaces.
     *
     * @param host - The host to listen on
     */
    setHost(host: string): ServiceBuilder;
    /**
     * Sets the logger to use for service-specific logging.
     *
     * If no logger is given, the default root logger is used.
     *
     * @param logger - A winston logger
     */
    setLogger(logger: LoggerService): ServiceBuilder;
    /**
     * Enables CORS handling using the given settings.
     *
     * If this method is not called, the resulting service will not have any
     * built in CORS handling.
     *
     * @param options - Standard CORS options
     */
    enableCors(options: cors.CorsOptions): ServiceBuilder;
    /**
     * Configure self-signed certificate generation options.
     *
     * If this method is not called, the resulting service will use sensible defaults
     *
     * @param options - Standard certificate options
     */
    setHttpsSettings(settings: {
        certificate: {
            key: string;
            cert: string;
        } | {
            hostname: string;
        };
    }): ServiceBuilder;
    /**
     * Adds a router (similar to the express .use call) to the service.
     *
     * @param root - The root URL to bind to (e.g. "/api/function1")
     * @param router - An express router
     */
    addRouter(root: string, router: Router | RequestHandler): ServiceBuilder;
    /**
     * Set the request logging handler
     *
     * If no handler is given the default one is used
     *
     * @param requestLoggingHandler - a factory function that given a logger returns an handler
     */
    setRequestLoggingHandler(requestLoggingHandler: RequestLoggingHandlerFactory): ServiceBuilder;
    /**
     * Sets an additional errorHandler to run before the defaultErrorHandler.
     *
     * For execution of only the custom error handler make sure to also invoke disableDefaultErrorHandler()
     * otherwise the defaultErrorHandler is executed at the end of the error middleware chain.
     *
     * @param errorHandler - an error handler
     */
    setErrorHandler(errorHandler: ErrorRequestHandler): ServiceBuilder;
    /**
     * Disables the default error handler
     */
    disableDefaultErrorHandler(): ServiceBuilder;
    /**
     * Starts the server using the given settings.
     */
    start(): Promise<Server>;
};
/**
 * A factory for request loggers.
 *
 * @public
 * @deprecated This type is being deprecated along with the {@link @backstage/backend-common#createServiceBuilder} function.
 */
type RequestLoggingHandlerFactory = (logger?: LoggerService) => RequestHandler;

/**
 * Creates a new service builder.
 * @public
 * @deprecated We are going to deprecated this old way of creating services in a near future, if you are using this service helper, please checkout the {@link https://backstage.io/docs/backend-system/building-backends/migrating | backend} and {@link https://backstage.io/docs/backend-system/building-plugins-and-modules/migrating | plugin} migration guides.
 */
declare function createServiceBuilder(_module: NodeModule): ServiceBuilder;

/**
 * Creates a default status checking router, that you can add to your express
 * app.
 *
 * @remarks
 *
 * This adds a `/healthcheck` route (or any other path, if given as an
 * argument), which your infra can call to see if the service is ready to serve
 * requests.
 *
 * @public
 * @deprecated Migrate to the {@link https://backstage.io/docs/backend-system/ | new backend system} and use the {@link https://backstage.io/docs/backend-system/core-services/root-health | Root Health Service} instead.
 */
declare function createStatusCheckRouter(options: {
    logger: LoggerService;
    /**
     * The path (including a leading slash) that the health check should be
     * mounted on.
     *
     * @defaultValue '/healthcheck'
     */
    path?: string;
    /**
     * If not implemented, the default express middleware always returns 200.
     * Override this to implement your own logic for a health check.
     */
    statusCheck?: StatusCheck;
}): Promise<express.Router>;

/**
 * Options passed to the {@link errorHandler} middleware.
 *
 * @public
 * @deprecated This type is being deprecated along with the {@link @backstage/backend-common#errorHandler} function.
 */
type ErrorHandlerOptions = {
    /**
     * Whether error response bodies should show error stack traces or not.
     *
     * If not specified, by default shows stack traces only in development mode.
     */
    showStackTraces?: boolean;
    /**
     * Logger instance to log errors.
     *
     * If not specified, the root logger will be used.
     */
    logger?: LoggerService;
    /**
     * Whether any 4xx errors should be logged or not.
     *
     * If not specified, default to only logging 5xx errors.
     */
    logClientErrors?: boolean;
};
/**
 * Express middleware to handle errors during request processing.
 *
 * This is commonly the very last middleware in the chain.
 *
 * Its primary purpose is not to do translation of business logic exceptions,
 * but rather to be a global catch-all for uncaught "fatal" errors that are
 * expected to result in a 500 error. However, it also does handle some common
 * error types (such as http-error exceptions) and returns the enclosed status
 * code accordingly.
 *
 * @public
 * @returns An Express error request handler
 * @deprecated Use {@link @backstage/backend-defaults/rootHttpRouter#MiddlewareFactory.create.error} instead
 */
declare function errorHandler(options?: ErrorHandlerOptions): ErrorRequestHandler;

/**
 * Express middleware to handle requests for missing routes.
 *
 * Should be used as the very last handler in the chain, as it unconditionally
 * returns a 404 status.
 *
 * @public
 * @returns An Express request handler
 * @deprecated Use {@link @backstage/backend-app-api#MiddlewareFactory.create.notFound} instead
 */
declare function notFoundHandler(): RequestHandler;

/**
 * Logs incoming requests.
 *
 * @public
 * @param logger - An optional logger to use. If not specified, the root logger will be used.
 * @returns An Express request handler
 * @deprecated Use {@link @backstage/backend-app-api#MiddlewareFactory.create.logging} instead
 */
declare function requestLoggingHandler(logger?: LoggerService): RequestHandler;

/**
 * A custom status checking function, passed to {@link statusCheckHandler} and
 * {@link createStatusCheckRouter}.
 *
 * @public
 * @deprecated Migrate to the {@link https://backstage.io/docs/backend-system/ | new backend system} and use the {@link https://backstage.io/docs/backend-system/core-services/root-health | Root Health Service} instead.
 */
type StatusCheck = () => Promise<any>;
/**
 * Options passed to {@link statusCheckHandler}.
 *
 * @public
 * @deprecated Migrate to the {@link https://backstage.io/docs/backend-system/ | new backend system} and use the {@link https://backstage.io/docs/backend-system/core-services/root-health | Root Health Service} instead.
 */
interface StatusCheckHandlerOptions {
    /**
     * Optional status function which returns a message.
     */
    statusCheck?: StatusCheck;
}
/**
 * Express middleware for status checks.
 *
 * This is commonly used to implement healthcheck and readiness routes.
 *
 * @public
 * @param options - An optional configuration object.
 * @returns An Express error request handler
 * @deprecated Migrate to the {@link https://backstage.io/docs/backend-system/ | new backend system} and use the {@link https://backstage.io/docs/backend-system/core-services/root-health | Root Health Service} instead.
 */
declare function statusCheckHandler(options?: StatusCheckHandlerOptions): Promise<RequestHandler>;

/**
 *   Allows defining access credentials for a registry
 *   Follows dockerode auth configuration:
 *   {@link https://github.com/apocas/dockerode?tab=readme-ov-file#pull-from-private-repos}
 *
 *   @public
 *   @deprecated This interface is deprecated and will be removed in a future release.
 */
interface PullOptions {
    authconfig?: {
        username?: string;
        password?: string;
        auth?: string;
        email?: string;
        serveraddress?: string;
        [key: string]: unknown;
    };
    [key: string]: unknown;
}
/**
 * Options passed to the {@link ContainerRunner.runContainer} method.
 *
 * @public
 * @deprecated This type is deprecated and will be removed in a future release.
 */
type RunContainerOptions = {
    imageName: string;
    command?: string | string[];
    args: string[];
    logStream?: Writable;
    mountDirs?: Record<string, string>;
    workingDir?: string;
    envVars?: Record<string, string>;
    pullImage?: boolean;
    defaultUser?: boolean;
    pullOptions?: PullOptions;
};
/**
 * Handles the running of containers, on behalf of others.
 *
 * @public
 * @deprecated This interface is deprecated and will be removed in a future release.
 */
interface ContainerRunner {
    /**
     * Runs a container image to completion.
     */
    runContainer(opts: RunContainerOptions): Promise<void>;
}

/**
 * A {@link ContainerRunner} for Docker containers.
 *
 * @public
 * @deprecated This class is deprecated and will be removed in a future release.
 */
declare class DockerContainerRunner implements ContainerRunner {
    private readonly dockerClient;
    constructor(options: {
        dockerClient: Docker;
    });
    runContainer(options: RunContainerOptions): Promise<void>;
}

/**
 * An existing Kubernetes volume that will be used as base for mounts.
 *
 * Every mount must start with the 'basePath'.
 *
 * @public
 * @deprecated This type is deprecated and will be removed in a future release.
 */
type KubernetesContainerRunnerMountBase = {
    volumeName: string;
    basePath: string;
};
/**
 * Options to create a {@link KubernetesContainerRunner}
 *
 * Kubernetes Jobs will be created on the provided 'namespace'
 * and their names will be prefixed with the provided 'name'.
 *
 * 'podTemplate' defines a Pod template for the Jobs. It has to include
 * a volume definition named as the {@link KubernetesContainerRunnerMountBase} 'volumeName'.
 *
 * @public
 * @deprecated This type is deprecated and will be removed in a future release.
 */
type KubernetesContainerRunnerOptions = {
    kubeConfig: KubeConfig;
    name: string;
    namespace?: string;
    mountBase?: KubernetesContainerRunnerMountBase;
    podTemplate?: V1PodTemplateSpec;
    timeoutMs?: number;
};
/**
 * A {@link ContainerRunner} for Kubernetes.
 *
 * Runs containers leveraging Jobs on a Kubernetes cluster
 *
 * @public
 * @deprecated This class is deprecated and will be removed in a future release.
 */
declare class KubernetesContainerRunner implements ContainerRunner {
    private readonly kubeConfig;
    private readonly batchV1Api;
    private readonly log;
    private readonly name;
    private readonly namespace;
    private readonly mountBase?;
    private readonly podTemplate?;
    private readonly timeoutMs;
    private readonly containerName;
    private getNamespace;
    private validateMountBase;
    constructor(options: KubernetesContainerRunnerOptions);
    runContainer(options: RunContainerOptions): Promise<void>;
    private handleError;
    private watchPod;
    private tailLogs;
    private waitPod;
    private createJob;
    private runJob;
}

/**
 * @public
 * @deprecated Use `DiscoveryService` from `@backstage/backend-plugin-api` instead
 */
type PluginEndpointDiscovery = DiscoveryService;
/**
 * HostDiscovery is a basic PluginEndpointDiscovery implementation
 * that can handle plugins that are hosted in a single or multiple deployments.
 *
 * The deployment may be scaled horizontally, as long as the external URL
 * is the same for all instances. However, internal URLs will always be
 * resolved to the same host, so there won't be any balancing of internal traffic.
 *
 * @public
 * @deprecated Please import from `@backstage/backend-defaults/discovery` instead.
 */
declare class HostDiscovery implements DiscoveryService {
    private readonly impl;
    /**
     * Creates a new HostDiscovery discovery instance by reading
     * from the `backend` config section, specifically the `.baseUrl` for
     * discovering the external URL, and the `.listen` and `.https` config
     * for the internal one.
     *
     * Can be overridden in config by providing a target and corresponding plugins in `discovery.endpoints`.
     * eg.
     * ```yaml
     * discovery:
     *  endpoints:
     *    - target: https://internal.example.com/internal-catalog
     *      plugins: [catalog]
     *    - target: https://internal.example.com/secure/api/{{pluginId}}
     *      plugins: [auth, permission]
     *    - target:
     *        internal: https://internal.example.com/search
     *        external: https://example.com/search
     *      plugins: [search]
     * ```
     *
     * The basePath defaults to `/api`, meaning the default full internal
     * path for the `catalog` plugin will be `http://localhost:7007/api/catalog`.
     */
    static fromConfig(config: Config, options?: {
        basePath?: string;
    }): HostDiscovery;
    private constructor();
    getBaseUrl(pluginId: string): Promise<string>;
    getExternalBaseUrl(pluginId: string): Promise<string>;
}

/**
 * @public
 * @deprecated Use `CacheManager` from the `@backstage/backend-defaults` package instead
 */
declare class CacheManager extends CacheManager$1 {
}
/**
 * @public
 * @deprecated Use `CacheManagerOptions` from the `@backstage/backend-defaults` package instead
 */
type CacheManagerOptions = CacheManagerOptions$1;
/**
 * @public
 * @deprecated Use `PluginCacheManager` from the `@backstage/backend-defaults` package instead
 */
type PluginCacheManager = PluginCacheManager$1;
/**
 * @public
 * @deprecated Use `CacheService` from the `@backstage/backend-plugin-api` package instead
 */
type CacheClient = CacheService;
/**
 * @public
 * @deprecated Use `CacheServiceSetOptions` from the `@backstage/backend-plugin-api` package instead
 */
type CacheClientSetOptions = CacheServiceSetOptions;
/**
 * @public
 * @deprecated Use `CacheServiceOptions` from the `@backstage/backend-plugin-api` package instead
 */
type CacheClientOptions = CacheServiceOptions;
/**
 * @public
 * @deprecated Use `DatabaseManager` from the `@backstage/backend-defaults` package instead
 */
declare class DatabaseManager implements LegacyRootDatabaseService {
    private readonly _databaseManager;
    private constructor();
    static fromConfig(config: Config, options?: DatabaseManagerOptions): DatabaseManager;
    forPlugin(pluginId: string, deps?: {
        lifecycle: LifecycleService;
        pluginMetadata: PluginMetadataService;
    } | undefined): PluginDatabaseManager;
}
/**
 * @public
 * @deprecated Use `DatabaseManagerOptions` from the `@backstage/backend-defaults` package instead
 */
type DatabaseManagerOptions = DatabaseManagerOptions$1;
/**
 * @public
 * @deprecated Use `DatabaseService` from the `@backstage/backend-plugin-api` package instead
 */
type PluginDatabaseManager = DatabaseService;
/**
 * @public
 * @deprecated Use `LegacyRootDatabaseService` from the `@backstage/backend-defaults` package instead
 */
type LegacyRootDatabaseService = LegacyRootDatabaseService$1;
/**
 * @public
 * @deprecated Use `dropDatabase` from the `@backstage/backend-defaults` package instead
 */
declare const dropDatabase: typeof dropDatabase$1;
/**
 * @public
 * @deprecated This function is deprecated and will be removed in a future release, see https://github.com/backstage/backstage/issues/24493.
 * Please use the `isDatabaseConflictError` function from the `@backstage/backend-plugin-api` package instead.
 */
declare const isDatabaseConflictError: typeof isDatabaseConflictError$1;
/**
 * @public
 * @deprecated This function is deprecated and will be removed in a future release, see https://github.com/backstage/backstage/issues/24493.
 * Please use the `resolvePackagePath` function from the `@backstage/backend-plugin-api` package instead.
 */
declare const resolvePackagePath: typeof resolvePackagePath$1;
/**
 * @public
 * @deprecated This function is deprecated and will be removed in a future release, see https://github.com/backstage/backstage/issues/24493.
 * Please use the `resolveSafeChildPath` function from the `@backstage/backend-plugin-api` package instead.
 */
declare const resolveSafeChildPath: typeof resolveSafeChildPath$1;
/**
 * @public
 * @deprecated This function is deprecated and will be removed in a future release, see https://github.com/backstage/backstage/issues/24493.
 * Please use the `isChildPath` function from the `@backstage/cli-common` package instead.
 */
declare const isChildPath: typeof isChildPath$1;
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
declare class AzureUrlReader extends AzureUrlReader$1 {
}
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
declare class BitbucketCloudUrlReader extends BitbucketCloudUrlReader$1 {
}
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
declare class BitbucketUrlReader extends BitbucketUrlReader$1 {
}
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
declare class BitbucketServerUrlReader extends BitbucketServerUrlReader$1 {
}
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
declare class GerritUrlReader extends GerritUrlReader$1 {
}
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
declare class GithubUrlReader extends GithubUrlReader$1 {
}
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
declare class GitlabUrlReader extends GitlabUrlReader$1 {
}
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
declare class GiteaUrlReader extends GiteaUrlReader$1 {
}
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
declare class HarnessUrlReader extends HarnessUrlReader$1 {
}
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
declare class AwsS3UrlReader extends AwsS3UrlReader$1 {
}
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
declare class FetchUrlReader extends FetchUrlReader$1 {
}
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
declare class UrlReaders extends UrlReaders$1 {
}
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
declare class ReadUrlResponseFactory extends ReadUrlResponseFactory$1 {
}
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
type UrlReadersOptions = UrlReadersOptions$1;
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
type FromReadableArrayOptions = FromReadableArrayOptions$1;
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
type ReaderFactory = ReaderFactory$1;
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
type ReadTreeResponseFactory = ReadTreeResponseFactory$1;
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
type ReadTreeResponseFactoryOptions = ReadTreeResponseFactoryOptions$1;
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
type ReadUrlResponseFactoryFromStreamOptions = ReadUrlResponseFactoryFromStreamOptions$1;
/**
 * @public
 * @deprecated Import from `@backstage/backend-defaults/urlReader` instead
 */
type UrlReaderPredicateTuple = UrlReaderPredicateTuple$1;
/**
 * @public
 * @deprecated Use `UrlReaderServiceReadTreeOptions` from `@backstage/backend-plugin-api` instead
 */
type ReadTreeOptions = ReadTreeOptions$1;
/**
 * @public
 * @deprecated Use `UrlReaderServiceReadTreeResponse` from `@backstage/backend-plugin-api` instead
 */
type ReadTreeResponse = ReadTreeResponse$1;
/**
 * @public
 * @deprecated Use `UrlReaderServiceReadTreeResponseFile` from `@backstage/backend-plugin-api` instead
 */
type ReadTreeResponseFile = ReadTreeResponseFile$1;
/**
 * @public
 * @deprecated Use `UrlReaderServiceReadTreeResponseDirOptions` from `@backstage/backend-plugin-api` instead
 */
type ReadTreeResponseDirOptions = ReadTreeResponseDirOptions$1;
/**
 * @public
 * @deprecated Use `UrlReaderServiceReadUrlOptions` from `@backstage/backend-plugin-api` instead
 */
type ReadUrlOptions = ReadUrlOptions$1;
/**
 * @public
 * @deprecated Use `UrlReaderServiceReadUrlResponse` from `@backstage/backend-plugin-api` instead
 */
type ReadUrlResponse = ReadUrlResponse$1;
/**
 * @public
 * @deprecated Use `UrlReaderServiceSearchOptions` from `@backstage/backend-plugin-api` instead
 */
type SearchOptions = SearchOptions$1;
/**
 * @public
 * @deprecated Use `UrlReaderServiceSearchResponse` from `@backstage/backend-plugin-api` instead
 */
type SearchResponse = SearchResponse$1;
/**
 * @public
 * @deprecated Use `UrlReaderServiceSearchResponseFile` from `@backstage/backend-plugin-api` instead
 */
type SearchResponseFile = SearchResponseFile$1;
/**
 * @public
 * @deprecated Use `UrlReaderService` from `@backstage/backend-plugin-api` instead
 */
type UrlReader = UrlReaderService;

/**
 * @public
 */
type LegacyCreateRouter<TEnv> = (deps: TEnv) => Promise<RequestHandler>;
/** @ignore */
type TransformedEnv<TEnv extends Record<string, unknown>, TEnvTransforms extends {
    [key in keyof TEnv]?: (dep: TEnv[key]) => unknown;
}> = {
    [key in keyof TEnv]: TEnvTransforms[key] extends (dep: TEnv[key]) => infer R ? R : TEnv[key];
};
/**
 * Creates a new custom plugin compatibility wrapper.
 *
 * @public
 * @remarks
 *
 * Usually you can use {@link legacyPlugin} directly instead, but you might
 * need to use this if you have customized the plugin environment in your backend.
 */
declare function makeLegacyPlugin<TEnv extends Record<string, unknown>, TEnvTransforms extends {
    [key in keyof TEnv]?: (dep: TEnv[key]) => unknown;
}>(envMapping: {
    [key in keyof TEnv]: ServiceRef<TEnv[key]>;
}, envTransforms: TEnvTransforms): (name: string, createRouterImport: Promise<{
    default: LegacyCreateRouter<TransformedEnv<TEnv, TEnvTransforms>>;
}>) => _backstage_backend_plugin_api.BackendFeatureCompat;
/**
 * Helper function to create a plugin from a legacy createRouter function and
 * register it with the http router based on the plugin id.
 *
 * @public
 * @remarks
 *
 * This is intended to be used by plugin authors to ease the transition to the
 * new backend system.
 *
 * @example
 *
 *```ts
 *backend.add(legacyPlugin('kafka', import('./plugins/kafka')));
 *```
 */
declare const legacyPlugin: (name: string, createRouterImport: Promise<{
    default: LegacyCreateRouter<TransformedEnv<{
        cache: _backstage_backend_plugin_api.CacheService;
        config: _backstage_backend_plugin_api.RootConfigService;
        database: _backstage_backend_plugin_api.DatabaseService;
        discovery: _backstage_backend_plugin_api.DiscoveryService;
        logger: _backstage_backend_plugin_api.LoggerService;
        permissions: _backstage_backend_plugin_api.PermissionsService;
        scheduler: _backstage_backend_plugin_api.SchedulerService;
        tokenManager: _backstage_backend_plugin_api.TokenManagerService;
        reader: _backstage_backend_plugin_api.UrlReaderService;
        identity: _backstage_backend_plugin_api.IdentityService;
    }, {
        logger: (log: _backstage_backend_plugin_api.LoggerService) => winston.Logger;
        cache: (cache: _backstage_backend_plugin_api.CacheService) => {
            getClient(options?: _backstage_backend_plugin_api.CacheServiceOptions | undefined): _backstage_backend_plugin_api.CacheService;
        };
    }>>;
}>) => _backstage_backend_plugin_api.BackendFeatureCompat;

/**
 * An adapter that ensures presence of the auth and/or httpAuth services.
 * @public
 */
declare function createLegacyAuthAdapters<TOptions extends {
    auth?: AuthService;
    httpAuth?: HttpAuthService;
    userInfo?: UserInfoService;
    identity?: IdentityService;
    tokenManager?: TokenManager;
    discovery: PluginEndpointDiscovery;
}, TAdapters = (TOptions extends {
    auth?: AuthService;
} ? {
    auth: AuthService;
} : {}) & (TOptions extends {
    httpAuth?: HttpAuthService;
} ? {
    httpAuth: HttpAuthService;
} : {}) & (TOptions extends {
    userInfo?: UserInfoService;
} ? {
    userInfo: UserInfoService;
} : {})>(options: TOptions): TAdapters;

/**
 * Compatibility wrapper for going from a new-backend cache service to the
 * old-backend plugin cache manager.
 *
 * @public
 */
declare function cacheToPluginCacheManager(cache: CacheService): {
    getClient(options?: CacheServiceOptions): CacheService;
};

/** @public */
declare function loggerToWinstonLogger(logger: LoggerService, opts?: TransportStreamOptions): Logger;

export { type AuthCallbackOptions, AwsS3UrlReader, AzureUrlReader, BitbucketCloudUrlReader, BitbucketServerUrlReader, BitbucketUrlReader, type CacheClient, type CacheClientOptions, type CacheClientSetOptions, CacheManager, type CacheManagerOptions, type ContainerRunner, DatabaseManager, type DatabaseManagerOptions, DockerContainerRunner, type ErrorHandlerOptions, FetchUrlReader, type FromReadableArrayOptions, GerritUrlReader, Git, GiteaUrlReader, GithubUrlReader, GitlabUrlReader, HarnessUrlReader, HostDiscovery, KubernetesContainerRunner, type KubernetesContainerRunnerMountBase, type KubernetesContainerRunnerOptions, type LegacyCreateRouter, type LegacyRootDatabaseService, type PluginCacheManager, type PluginDatabaseManager, type PluginEndpointDiscovery, type PullOptions, type ReadTreeOptions, type ReadTreeResponse, type ReadTreeResponseDirOptions, type ReadTreeResponseFactory, type ReadTreeResponseFactoryOptions, type ReadTreeResponseFile, type ReadUrlOptions, type ReadUrlResponse, ReadUrlResponseFactory, type ReadUrlResponseFactoryFromStreamOptions, type ReaderFactory, type RequestLoggingHandlerFactory, type RunContainerOptions, type SearchOptions, type SearchResponse, type SearchResponseFile, ServerTokenManager, type ServerTokenManagerOptions, type ServiceBuilder, HostDiscovery as SingleHostDiscovery, type StaticAuthOptions, type StatusCheck, type StatusCheckHandlerOptions, type TokenManager, type UrlReader, type UrlReaderPredicateTuple, UrlReaders, type UrlReadersOptions, cacheToPluginCacheManager, coloredFormat, createLegacyAuthAdapters, createRootLogger, createServiceBuilder, createStatusCheckRouter, dropDatabase, errorHandler, getRootLogger, getVoidLogger, isChildPath, isDatabaseConflictError, legacyPlugin, loadBackendConfig, loggerToWinstonLogger, makeLegacyPlugin, notFoundHandler, redactWinstonLogLine, requestLoggingHandler, resolvePackagePath, resolveSafeChildPath, setRootLogger, statusCheckHandler, useHotCleanup, useHotMemoize };
