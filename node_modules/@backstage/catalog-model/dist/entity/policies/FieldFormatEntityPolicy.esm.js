import { CommonValidatorFunctions } from '../../validation/CommonValidatorFunctions.esm.js';
import 'ajv';
import { KubernetesValidatorFunctions } from '../../validation/KubernetesValidatorFunctions.esm.js';
import { makeValidator } from '../../validation/makeValidator.esm.js';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, key + "" , value);
  return value;
};
class FieldFormatEntityPolicy {
  constructor(validators = makeValidator()) {
    __publicField(this, "validators");
    this.validators = validators;
  }
  async enforce(entity) {
    var _a, _b, _c, _d, _e, _f, _g;
    function require2(field, value, validator) {
      if (value === void 0 || value === null) {
        throw new Error(`${field} must have a value`);
      }
      let isValid;
      try {
        isValid = validator(value);
      } catch (e) {
        throw new Error(`${field} could not be validated, ${e}`);
      }
      if (!isValid) {
        let expectation;
        switch (validator.name) {
          case "isValidLabelValue":
          case "isValidObjectName":
            expectation = "a string that is sequences of [a-zA-Z0-9] separated by any of [-_.], at most 63 characters in total";
            break;
          case "isValidLabelKey":
          case "isValidApiVersion":
          case "isValidAnnotationKey":
            expectation = "a valid prefix and/or suffix";
            break;
          case "isValidNamespace":
          case "isValidDnsLabel":
            expectation = "a string that is sequences of [a-z0-9] separated by [-], at most 63 characters in total";
            break;
          case "isValidTag":
            expectation = "a string that is sequences of [a-z0-9+#] separated by [-], at most 63 characters in total";
            break;
          case "isValidAnnotationValue":
            expectation = "a string";
            break;
          case "isValidKind":
            expectation = "a string that is a sequence of [a-zA-Z][a-z0-9A-Z], at most 63 characters in total";
            break;
          case "isValidUrl":
            expectation = "a string that is a valid url";
            break;
          case "isValidString":
          case "isNonEmptyString":
            expectation = "a non empty string";
            break;
          default:
            expectation = void 0;
            break;
        }
        const message = expectation ? ` expected ${expectation} but found "${value}".` : "";
        throw new Error(
          `"${field}" is not valid;${message} To learn more about catalog file format, visit: https://github.com/backstage/backstage/blob/master/docs/architecture-decisions/adr002-default-catalog-file-format.md`
        );
      }
    }
    function optional(field, value, validator) {
      return value === void 0 || require2(field, value, validator);
    }
    require2("apiVersion", entity.apiVersion, this.validators.isValidApiVersion);
    require2("kind", entity.kind, this.validators.isValidKind);
    require2("metadata.name", entity.metadata.name, this.validators.isValidEntityName);
    optional(
      "metadata.namespace",
      entity.metadata.namespace,
      this.validators.isValidNamespace
    );
    for (const [k, v] of Object.entries((_a = entity.metadata.labels) != null ? _a : [])) {
      require2(`labels.${k}`, k, this.validators.isValidLabelKey);
      require2(`labels.${k}`, v, this.validators.isValidLabelValue);
    }
    for (const [k, v] of Object.entries((_b = entity.metadata.annotations) != null ? _b : [])) {
      require2(`annotations.${k}`, k, this.validators.isValidAnnotationKey);
      require2(`annotations.${k}`, v, this.validators.isValidAnnotationValue);
    }
    const tags = (_c = entity.metadata.tags) != null ? _c : [];
    for (let i = 0; i < tags.length; ++i) {
      require2(`tags.${i}`, tags[i], this.validators.isValidTag);
    }
    const links = (_d = entity.metadata.links) != null ? _d : [];
    for (let i = 0; i < links.length; ++i) {
      require2(`links.${i}.url`, (_e = links[i]) == null ? void 0 : _e.url, CommonValidatorFunctions.isValidUrl);
      optional(
        `links.${i}.title`,
        (_f = links[i]) == null ? void 0 : _f.title,
        CommonValidatorFunctions.isNonEmptyString
      );
      optional(
        `links.${i}.icon`,
        (_g = links[i]) == null ? void 0 : _g.icon,
        KubernetesValidatorFunctions.isValidObjectName
      );
    }
    return entity;
  }
}

export { FieldFormatEntityPolicy };
//# sourceMappingURL=FieldFormatEntityPolicy.esm.js.map
