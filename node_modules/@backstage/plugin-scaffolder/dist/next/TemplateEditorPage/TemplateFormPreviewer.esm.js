import { useApi, alertApiRef } from '@backstage/core-plugin-api';
import { catalogApiRef, humanizeEntityRef } from '@backstage/plugin-catalog-react';
import FormControl from '@material-ui/core/FormControl';
import IconButton from '@material-ui/core/IconButton';
import InputLabel from '@material-ui/core/InputLabel';
import LinearProgress from '@material-ui/core/LinearProgress';
import MenuItem from '@material-ui/core/MenuItem';
import Select from '@material-ui/core/Select';
import { makeStyles } from '@material-ui/core/styles';
import CloseIcon from '@material-ui/icons/Close';
import React, { useState, useCallback } from 'react';
import useAsync from 'react-use/esm/useAsync';
import yaml from 'yaml';
import { TemplateEditorForm } from './TemplateEditorForm.esm.js';
import { TemplateEditorTextArea } from './TemplateEditorTextArea.esm.js';

const EXAMPLE_TEMPLATE_PARAMS_YAML = `# Edit the template parameters below to see how they will render in the scaffolder form UI
parameters:
  - title: Fill in some steps
    required:
      - name
    properties:
      name:
        title: Name
        type: string
        description: Unique name of the component
      owner:
        title: Owner
        type: string
        description: Owner of the component
        ui:field: OwnerPicker
        ui:options:
          catalogFilter:
            kind: Group
  - title: Choose a location
    required:
      - repoUrl
    properties:
      repoUrl:
        title: Repository Location
        type: string
        ui:field: RepoUrlPicker
        ui:options:
          allowedHosts:
            - github.com
steps:
  - id: fetch-base
    name: Fetch Base
    action: fetch:template
    input:
      url: ./template
      values:
        name: \${{parameters.name}}
`;
const useStyles = makeStyles((theme) => ({
  root: {
    gridArea: "pageContent",
    display: "grid",
    gridTemplateAreas: `
      "controls controls"
      "textArea preview"
    `,
    gridTemplateRows: "auto 1fr",
    gridTemplateColumns: "1fr 1fr"
  },
  controls: {
    gridArea: "controls",
    display: "flex",
    flexFlow: "row nowrap",
    alignItems: "center",
    margin: theme.spacing(1)
  },
  textArea: {
    gridArea: "textArea"
  },
  preview: {
    gridArea: "preview"
  }
}));
const TemplateFormPreviewer = ({
  defaultPreviewTemplate = EXAMPLE_TEMPLATE_PARAMS_YAML,
  customFieldExtensions = [],
  onClose,
  layouts = []
}) => {
  const classes = useStyles();
  const alertApi = useApi(alertApiRef);
  const catalogApi = useApi(catalogApiRef);
  const [selectedTemplate, setSelectedTemplate] = useState("");
  const [errorText, setErrorText] = useState();
  const [templateOptions, setTemplateOptions] = useState([]);
  const [templateYaml, setTemplateYaml] = useState(defaultPreviewTemplate);
  const { loading } = useAsync(
    () => catalogApi.getEntities({
      filter: { kind: "template" },
      fields: [
        "kind",
        "metadata.namespace",
        "metadata.name",
        "metadata.title",
        "spec.parameters",
        "spec.steps",
        "spec.output"
      ]
    }).then(
      ({ items }) => setTemplateOptions(
        items.map((template) => ({
          label: template.metadata.title ?? humanizeEntityRef(template, { defaultKind: "template" }),
          value: template
        }))
      )
    ).catch(
      (e) => alertApi.post({
        message: `Error loading exisiting templates: ${e.message}`,
        severity: "error"
      })
    ),
    [catalogApi]
  );
  const handleSelectChange = useCallback(
    // TODO(Rugvip): Afaik this should be Entity, but didn't want to make runtime changes while fixing types
    (selected) => {
      setSelectedTemplate(selected);
      setTemplateYaml(yaml.stringify(selected.spec));
    },
    [setTemplateYaml]
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, loading && /* @__PURE__ */ React.createElement(LinearProgress, null), /* @__PURE__ */ React.createElement("main", { className: classes.root }, /* @__PURE__ */ React.createElement("div", { className: classes.controls }, /* @__PURE__ */ React.createElement(FormControl, { variant: "outlined", size: "small", fullWidth: true }, /* @__PURE__ */ React.createElement(InputLabel, { id: "select-template-label" }, "Load Existing Template"), /* @__PURE__ */ React.createElement(
    Select,
    {
      value: selectedTemplate,
      label: "Load Existing Template",
      labelId: "select-template-label",
      onChange: (e) => handleSelectChange(e.target.value)
    },
    templateOptions.map((option, idx) => /* @__PURE__ */ React.createElement(MenuItem, { key: idx, value: option.value }, option.label))
  )), /* @__PURE__ */ React.createElement(IconButton, { size: "medium", onClick: onClose }, /* @__PURE__ */ React.createElement(CloseIcon, null))), /* @__PURE__ */ React.createElement("div", { className: classes.textArea }, /* @__PURE__ */ React.createElement(
    TemplateEditorTextArea,
    {
      content: templateYaml,
      onUpdate: setTemplateYaml,
      errorText
    }
  )), /* @__PURE__ */ React.createElement("div", { className: classes.preview }, /* @__PURE__ */ React.createElement(
    TemplateEditorForm,
    {
      content: templateYaml,
      contentIsSpec: true,
      fieldExtensions: customFieldExtensions,
      setErrorText,
      layouts
    }
  ))));
};

export { TemplateFormPreviewer };
//# sourceMappingURL=TemplateFormPreviewer.esm.js.map
