'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var alpha = require('@backstage/plugin-catalog-common/alpha');
var pluginPermissionNode = require('@backstage/plugin-permission-node');
var CatalogBuilder = require('./cjs/CatalogBuilder-D0vAEZa8.cjs.js');
var backendPluginApi = require('@backstage/backend-plugin-api');
var pluginEventsNode = require('@backstage/plugin-events-node');
var alpha$1 = require('@backstage/plugin-catalog-node/alpha');
var lodash = require('lodash');
var errors = require('@backstage/errors');
require('@backstage/backend-common');
require('@backstage/catalog-model');
require('@backstage/integration');
require('crypto');
require('core-js/features/promise');
require('codeowners-utils');
require('git-url-parse');
require('@backstage/plugin-catalog-node');
require('fs-extra');
require('glob');
require('path');
require('util');
require('yaml');
require('p-limit');
require('uuid');
require('luxon');
require('prom-client');
require('@opentelemetry/api');
require('fast-json-stable-stringify');
require('lodash/uniq');
require('lodash/chunk');
require('zod');
require('@backstage/types');
require('@backstage/catalog-client');
require('yn');
require('@backstage/backend-openapi-utils');
require('@backstage/plugin-permission-common');
require('minimatch');
require('@backstage/config');

const { conditions, createConditionalDecision } = pluginPermissionNode.createConditionExports({
  pluginId: "catalog",
  resourceType: alpha.RESOURCE_TYPE_CATALOG_ENTITY,
  rules: CatalogBuilder.permissionRules
});
const catalogConditions = conditions;
const createCatalogConditionalDecision = createConditionalDecision;

class CatalogProcessingExtensionPointImpl {
  #processors = new Array();
  #entityProviders = new Array();
  #placeholderResolvers = {};
  #onProcessingErrorHandler;
  addProcessor(...processors) {
    this.#processors.push(...processors.flat());
  }
  addEntityProvider(...providers) {
    this.#entityProviders.push(...providers.flat());
  }
  addPlaceholderResolver(key, resolver) {
    if (key in this.#placeholderResolvers)
      throw new Error(
        `A placeholder resolver for '${key}' has already been set up, please check your config.`
      );
    this.#placeholderResolvers[key] = resolver;
  }
  setOnProcessingErrorHandler(handler) {
    this.#onProcessingErrorHandler = handler;
  }
  get processors() {
    return this.#processors;
  }
  get entityProviders() {
    return this.#entityProviders;
  }
  get placeholderResolvers() {
    return this.#placeholderResolvers;
  }
  get onProcessingErrorHandler() {
    return this.#onProcessingErrorHandler;
  }
}
class CatalogPermissionExtensionPointImpl {
  #permissions = new Array();
  #permissionRules = new Array();
  addPermissions(...permission) {
    this.#permissions.push(...permission.flat());
  }
  addPermissionRules(...rules) {
    this.#permissionRules.push(...rules.flat());
  }
  get permissions() {
    return this.#permissions;
  }
  get permissionRules() {
    return this.#permissionRules;
  }
}
class CatalogModelExtensionPointImpl {
  #fieldValidators = {};
  setFieldValidators(validators) {
    lodash.merge(this.#fieldValidators, validators);
  }
  get fieldValidators() {
    return this.#fieldValidators;
  }
  #entityDataParser;
  setEntityDataParser(parser) {
    if (this.#entityDataParser) {
      throw new Error(
        "Attempted to install second EntityDataParser. Only one can be set."
      );
    }
    this.#entityDataParser = parser;
  }
  get entityDataParser() {
    return this.#entityDataParser;
  }
}
const catalogPlugin = backendPluginApi.createBackendPlugin({
  pluginId: "catalog",
  register(env) {
    const processingExtensions = new CatalogProcessingExtensionPointImpl();
    env.registerExtensionPoint(
      alpha$1.catalogProcessingExtensionPoint,
      processingExtensions
    );
    let locationAnalyzerFactory = void 0;
    const scmLocationAnalyzers = new Array();
    env.registerExtensionPoint(alpha$1.catalogAnalysisExtensionPoint, {
      setLocationAnalyzer(analyzerOrFactory) {
        if (locationAnalyzerFactory) {
          throw new Error("LocationAnalyzer has already been set");
        }
        if (typeof analyzerOrFactory === "function") {
          locationAnalyzerFactory = analyzerOrFactory;
        } else {
          locationAnalyzerFactory = async () => ({
            locationAnalyzer: analyzerOrFactory
          });
        }
      },
      addScmLocationAnalyzer(analyzer) {
        scmLocationAnalyzers.push(analyzer);
      }
    });
    const permissionExtensions = new CatalogPermissionExtensionPointImpl();
    env.registerExtensionPoint(
      alpha$1.catalogPermissionExtensionPoint,
      permissionExtensions
    );
    const modelExtensions = new CatalogModelExtensionPointImpl();
    env.registerExtensionPoint(alpha$1.catalogModelExtensionPoint, modelExtensions);
    env.registerInit({
      deps: {
        logger: backendPluginApi.coreServices.logger,
        config: backendPluginApi.coreServices.rootConfig,
        reader: backendPluginApi.coreServices.urlReader,
        permissions: backendPluginApi.coreServices.permissions,
        database: backendPluginApi.coreServices.database,
        httpRouter: backendPluginApi.coreServices.httpRouter,
        lifecycle: backendPluginApi.coreServices.rootLifecycle,
        scheduler: backendPluginApi.coreServices.scheduler,
        discovery: backendPluginApi.coreServices.discovery,
        auth: backendPluginApi.coreServices.auth,
        httpAuth: backendPluginApi.coreServices.httpAuth,
        events: pluginEventsNode.eventsServiceRef
      },
      async init({
        logger,
        config,
        reader,
        database,
        permissions,
        httpRouter,
        lifecycle,
        scheduler,
        discovery,
        auth,
        httpAuth,
        events
      }) {
        const builder = await CatalogBuilder.CatalogBuilder.create({
          config,
          reader,
          permissions,
          database,
          scheduler,
          logger,
          discovery,
          auth,
          httpAuth
        });
        builder.setEventBroker(events);
        if (processingExtensions.onProcessingErrorHandler) {
          builder.subscribe({
            onProcessingError: processingExtensions.onProcessingErrorHandler
          });
        }
        builder.addProcessor(...processingExtensions.processors);
        builder.addEntityProvider(...processingExtensions.entityProviders);
        if (modelExtensions.entityDataParser) {
          builder.setEntityDataParser(modelExtensions.entityDataParser);
        }
        Object.entries(processingExtensions.placeholderResolvers).forEach(
          ([key, resolver]) => builder.setPlaceholderResolver(key, resolver)
        );
        if (locationAnalyzerFactory) {
          const { locationAnalyzer } = await locationAnalyzerFactory({
            scmLocationAnalyzers
          }).catch((e) => {
            throw new errors.ForwardedError("Failed to create LocationAnalyzer", e);
          });
          builder.setLocationAnalyzer(locationAnalyzer);
        } else {
          builder.addLocationAnalyzers(...scmLocationAnalyzers);
        }
        builder.addPermissions(...permissionExtensions.permissions);
        builder.addPermissionRules(...permissionExtensions.permissionRules);
        builder.setFieldFormatValidators(modelExtensions.fieldValidators);
        const { processingEngine, router } = await builder.build();
        lifecycle.addStartupHook(async () => {
          await processingEngine.start();
        });
        lifecycle.addShutdownHook(() => processingEngine.stop());
        httpRouter.use(router);
      }
    });
  }
});

exports.createCatalogPermissionRule = CatalogBuilder.createCatalogPermissionRule;
exports.permissionRules = CatalogBuilder.permissionRules;
exports.catalogConditions = catalogConditions;
exports.createCatalogConditionalDecision = createCatalogConditionalDecision;
exports.default = catalogPlugin;
//# sourceMappingURL=alpha.cjs.js.map
