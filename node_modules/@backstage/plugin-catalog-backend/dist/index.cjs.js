'use strict';

var CatalogBuilder = require('./cjs/CatalogBuilder-D0vAEZa8.cjs.js');
var integration = require('@backstage/integration');
var parseGitUrl = require('git-url-parse');
var lodash = require('lodash');
var path = require('path');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');
var catalogModel = require('@backstage/catalog-model');
var catalogClient = require('@backstage/catalog-client');
var alpha = require('@backstage/plugin-catalog-common/alpha');
var pluginSearchBackendModuleCatalog = require('@backstage/plugin-search-backend-module-catalog');
require('@backstage/backend-common');
require('crypto');
require('@backstage/errors');
require('core-js/features/promise');
require('codeowners-utils');
require('fs-extra');
require('glob');
require('util');
require('yaml');
require('p-limit');
require('uuid');
require('@backstage/backend-plugin-api');
require('luxon');
require('prom-client');
require('@opentelemetry/api');
require('fast-json-stable-stringify');
require('lodash/uniq');
require('lodash/chunk');
require('zod');
require('@backstage/types');
require('yn');
require('@backstage/backend-openapi-utils');
require('@backstage/plugin-permission-common');
require('minimatch');
require('@backstage/config');
require('@backstage/plugin-permission-node');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var parseGitUrl__default = /*#__PURE__*/_interopDefaultCompat(parseGitUrl);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);

const GITHUB_ACTIONS_ANNOTATION = "github.com/project-slug";
const GITLAB_ACTIONS_ANNOTATION = "gitlab.com/project-slug";
const AZURE_ACTIONS_ANNOTATION = "dev.azure.com/project-repo";
class AnnotateScmSlugEntityProcessor {
  constructor(opts) {
    this.opts = opts;
  }
  getProcessorName() {
    return "AnnotateScmSlugEntityProcessor";
  }
  static fromConfig(config, options) {
    return new AnnotateScmSlugEntityProcessor({
      scmIntegrationRegistry: integration.ScmIntegrations.fromConfig(config),
      kinds: options?.kinds
    });
  }
  async preProcessEntity(entity, location) {
    const applicableKinds = (this.opts.kinds ?? ["Component"]).map(
      (k) => k.toLocaleLowerCase("en-US")
    );
    if (!applicableKinds.includes(entity.kind.toLocaleLowerCase("en-US")) || location.type !== "url") {
      return entity;
    }
    const scmIntegration = this.opts.scmIntegrationRegistry.byUrl(
      location.target
    );
    if (!scmIntegration) {
      return entity;
    }
    let annotation;
    switch (scmIntegration.type) {
      case "github":
        annotation = GITHUB_ACTIONS_ANNOTATION;
        break;
      case "gitlab":
        annotation = GITLAB_ACTIONS_ANNOTATION;
        break;
      case "azure":
        annotation = AZURE_ACTIONS_ANNOTATION;
        break;
      default:
        return entity;
    }
    let projectSlug = entity.metadata.annotations?.[annotation];
    if (!projectSlug) {
      const gitUrl = parseGitUrl__default.default(location.target);
      projectSlug = `${gitUrl.owner}/${gitUrl.name}`;
    }
    return lodash.merge(
      {
        metadata: {
          annotations: lodash.pickBy(
            {
              [annotation]: projectSlug
            },
            lodash.identity
          )
        }
      },
      entity
    );
  }
}

function toAbsoluteUrl(integrations, base, target) {
  try {
    if (base.type === "file") {
      if (target.startsWith(".")) {
        return path__default.default.join(path__default.default.dirname(base.target), target);
      }
      return target;
    }
    return integrations.resolveUrl({ url: target, base: base.target });
  } catch (e) {
    return target;
  }
}
class LocationEntityProcessor {
  constructor(options) {
    this.options = options;
  }
  getProcessorName() {
    return "LocationEntityProcessor";
  }
  async postProcessEntity(entity, location, emit) {
    if (entity.kind === "Location") {
      const locationEntity = entity;
      const type = locationEntity.spec.type || location.type;
      if (type === "file" && location.target.endsWith(path__default.default.sep)) {
        emit(
          pluginCatalogNode.processingResult.inputError(
            location,
            `LocationEntityProcessor cannot handle ${type} type location with target ${location.target} that ends with a path separator`
          )
        );
      }
      const targets = new Array();
      if (locationEntity.spec.target) {
        targets.push(locationEntity.spec.target);
      }
      if (locationEntity.spec.targets) {
        targets.push(...locationEntity.spec.targets);
      }
      for (const maybeRelativeTarget of targets) {
        const target = toAbsoluteUrl(
          this.options.integrations,
          location,
          maybeRelativeTarget
        );
        emit(pluginCatalogNode.processingResult.location({ type, target }));
      }
    }
    return entity;
  }
}

function transformLegacyPolicyToProcessor(policy) {
  return {
    getProcessorName() {
      return policy.constructor.name;
    },
    async preProcessEntity(entity) {
      const result = await policy.enforce(entity);
      if (!result) {
        return entity;
      }
      return result;
    }
  };
}

class DefaultCatalogCollator {
  discovery;
  locationTemplate;
  filter;
  catalogClient;
  type = "software-catalog";
  visibilityPermission = alpha.catalogEntityReadPermission;
  tokenManager;
  static fromConfig(_config, options) {
    return new DefaultCatalogCollator({
      ...options
    });
  }
  constructor(options) {
    const { discovery, locationTemplate, filter, catalogClient: catalogClient$1, tokenManager } = options;
    this.discovery = discovery;
    this.locationTemplate = locationTemplate || "/catalog/:namespace/:kind/:name";
    this.filter = filter;
    this.catalogClient = catalogClient$1 || new catalogClient.CatalogClient({ discoveryApi: discovery });
    this.tokenManager = tokenManager;
  }
  applyArgsToFormat(format, args) {
    let formatted = format;
    for (const [key, value] of Object.entries(args)) {
      formatted = formatted.replace(`:${key}`, value);
    }
    return formatted.toLowerCase();
  }
  getDocumentText(entity) {
    let documentText = entity.metadata.description || "";
    if (catalogModel.isUserEntity(entity)) {
      if (entity.spec?.profile?.displayName && documentText) {
        const displayName = entity.spec?.profile?.displayName;
        documentText = displayName.concat(" : ", documentText);
      } else {
        documentText = entity.spec?.profile?.displayName || documentText;
      }
    }
    return documentText;
  }
  async execute() {
    const { token } = await this.tokenManager.getToken();
    const response = await this.catalogClient.getEntities(
      {
        filter: this.filter
      },
      { token }
    );
    return response.items.map((entity) => {
      return {
        title: entity.metadata.title ? `${entity.metadata.title} (${entity.metadata.name})` : entity.metadata.name,
        location: this.applyArgsToFormat(this.locationTemplate, {
          namespace: entity.metadata.namespace || "default",
          kind: entity.kind,
          name: entity.metadata.name
        }),
        text: this.getDocumentText(entity),
        componentType: entity.spec?.type?.toString() || "other",
        type: entity.spec?.type?.toString() || "other",
        namespace: entity.metadata.namespace || "default",
        kind: entity.kind,
        lifecycle: entity.spec?.lifecycle || "",
        owner: entity.spec?.owner || "",
        authorization: {
          resourceRef: catalogModel.stringifyEntityRef(entity)
        }
      };
    });
  }
}

const locationSpecToMetadataName = pluginCatalogNode.locationSpecToMetadataName;
const locationSpecToLocationEntity = pluginCatalogNode.locationSpecToLocationEntity;
const processingResult = pluginCatalogNode.processingResult;
const DefaultCatalogCollatorFactory = pluginSearchBackendModuleCatalog.DefaultCatalogCollatorFactory;
const defaultCatalogCollatorEntityTransformer = pluginSearchBackendModuleCatalog.defaultCatalogCollatorEntityTransformer;

exports.AnnotateLocationEntityProcessor = CatalogBuilder.AnnotateLocationEntityProcessor;
exports.BuiltinKindsEntityProcessor = CatalogBuilder.BuiltinKindsEntityProcessor;
exports.CATALOG_CONFLICTS_TOPIC = CatalogBuilder.CATALOG_CONFLICTS_TOPIC;
exports.CATALOG_ERRORS_TOPIC = CatalogBuilder.CATALOG_ERRORS_TOPIC;
exports.CatalogBuilder = CatalogBuilder.CatalogBuilder;
exports.CodeOwnersProcessor = CatalogBuilder.CodeOwnersProcessor;
exports.FileReaderProcessor = CatalogBuilder.FileReaderProcessor;
exports.PlaceholderProcessor = CatalogBuilder.PlaceholderProcessor;
exports.UrlReaderProcessor = CatalogBuilder.UrlReaderProcessor;
exports.createRandomProcessingInterval = CatalogBuilder.createRandomProcessingInterval;
exports.parseEntityYaml = CatalogBuilder.parseEntityYaml;
exports.AnnotateScmSlugEntityProcessor = AnnotateScmSlugEntityProcessor;
exports.DefaultCatalogCollator = DefaultCatalogCollator;
exports.DefaultCatalogCollatorFactory = DefaultCatalogCollatorFactory;
exports.LocationEntityProcessor = LocationEntityProcessor;
exports.defaultCatalogCollatorEntityTransformer = defaultCatalogCollatorEntityTransformer;
exports.locationSpecToLocationEntity = locationSpecToLocationEntity;
exports.locationSpecToMetadataName = locationSpecToMetadataName;
exports.processingResult = processingResult;
exports.transformLegacyPolicyToProcessor = transformLegacyPolicyToProcessor;
//# sourceMappingURL=index.cjs.js.map
