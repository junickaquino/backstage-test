'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var pluginAuthNode = require('@backstage/plugin-auth-node');
var errors = require('@backstage/errors');
var jose = require('jose');
var fetch = require('node-fetch');
var backendPluginApi = require('@backstage/backend-plugin-api');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fetch__default = /*#__PURE__*/_interopDefaultCompat(fetch);

const CF_JWT_HEADER = "cf-access-jwt-assertion";
const COOKIE_AUTH_NAME = "CF_Authorization";
const CACHE_PREFIX = "providers/cloudflare-access/profile-v1";

class AuthHelper {
  constructor(teamName, serviceTokens, keySet, cache) {
    this.teamName = teamName;
    this.serviceTokens = serviceTokens;
    this.keySet = keySet;
    this.cache = cache;
  }
  static fromConfig(config, options) {
    const teamName = config.getString("teamName");
    const serviceTokens = (config.getOptionalConfigArray("serviceTokens") ?? [])?.map((cfg) => {
      return {
        token: cfg.getString("token"),
        subject: cfg.getString("subject")
      };
    });
    const keySet = jose.createRemoteJWKSet(
      new URL(`https://${teamName}.cloudflareaccess.com/cdn-cgi/access/certs`)
    );
    return new AuthHelper(teamName, serviceTokens, keySet, options?.cache);
  }
  async authenticate(req) {
    let jwt = req.header(CF_JWT_HEADER);
    if (!jwt) {
      jwt = req.cookies.CF_Authorization;
    }
    if (!jwt) {
      throw new errors.AuthenticationError(
        `Missing ${CF_JWT_HEADER} from Cloudflare Access`
      );
    }
    const verifyResult = await jose.jwtVerify(jwt, this.keySet, {
      issuer: `https://${this.teamName}.cloudflareaccess.com`
    });
    const isServiceToken = !verifyResult.payload.sub;
    const subject = isServiceToken ? verifyResult.payload.common_name : verifyResult.payload.sub;
    if (!subject) {
      throw new errors.AuthenticationError(
        `Missing both sub and common_name from Cloudflare Access JWT`
      );
    }
    const serviceToken = this.serviceTokens.find((st) => st.token === subject);
    if (isServiceToken && !serviceToken) {
      throw new errors.AuthenticationError(
        `${subject} is not a permitted Service Token.`
      );
    }
    const cacheKey = `${CACHE_PREFIX}/${subject}`;
    const cfAccessResultStr = await this.cache?.get(cacheKey);
    if (typeof cfAccessResultStr === "string") {
      const result = JSON.parse(cfAccessResultStr);
      return {
        ...result,
        token: jwt
      };
    }
    const claims = verifyResult.payload;
    try {
      let cfIdentity;
      if (serviceToken) {
        cfIdentity = {
          id: subject,
          name: "Bot",
          email: serviceToken.subject,
          groups: []
        };
      } else {
        cfIdentity = await this.getIdentityProfile(jwt);
      }
      const cfAccessResult = {
        claims,
        cfIdentity,
        expiresInSeconds: claims.exp - claims.iat
      };
      this.cache?.set(cacheKey, JSON.stringify(cfAccessResult));
      return {
        ...cfAccessResult,
        token: jwt
      };
    } catch (err) {
      throw new errors.ForwardedError(
        "Failed to populate access identity information",
        err
      );
    }
  }
  async getIdentityProfile(jwt) {
    const headers = new fetch.Headers();
    headers.set(CF_JWT_HEADER, jwt);
    headers.set("cookie", `${COOKIE_AUTH_NAME}=${jwt}`);
    try {
      const res = await fetch__default.default(
        `https://${this.teamName}.cloudflareaccess.com/cdn-cgi/access/get-identity`,
        { headers }
      );
      if (!res.ok) {
        throw await errors.ResponseError.fromResponse(res);
      }
      const cfIdentity = await res.json();
      return cfIdentity;
    } catch (err) {
      throw new errors.ForwardedError("getIdentityProfile failed", err);
    }
  }
}

function createCloudflareAccessAuthenticator(options) {
  return pluginAuthNode.createProxyAuthenticator({
    async defaultProfileTransform(result) {
      return {
        profile: {
          email: result.claims.email,
          displayName: result.cfIdentity.name
        }
      };
    },
    initialize({ config }) {
      return {
        helper: AuthHelper.fromConfig(config, { cache: options?.cache })
      };
    },
    async authenticate({ req }, { helper }) {
      const result = await helper.authenticate(req);
      return {
        result,
        providerInfo: result
      };
    }
  });
}

exports.cloudflareAccessSignInResolvers = void 0;
((cloudflareAccessSignInResolvers2) => {
  cloudflareAccessSignInResolvers2.emailMatchingUserEntityProfileEmail = pluginAuthNode.createSignInResolverFactory({
    create() {
      return async (info, ctx) => {
        const { profile } = info;
        if (!profile.email) {
          throw new Error(
            "Login failed, user profile does not contain an email"
          );
        }
        return ctx.signInWithCatalogUser({
          filter: {
            "spec.profile.email": profile.email
          }
        });
      };
    }
  });
})(exports.cloudflareAccessSignInResolvers || (exports.cloudflareAccessSignInResolvers = {}));

const authModuleCloudflareAccessProvider = backendPluginApi.createBackendModule({
  pluginId: "auth",
  moduleId: "cloudflare-access-provider",
  register(reg) {
    reg.registerInit({
      deps: {
        authProviders: pluginAuthNode.authProvidersExtensionPoint,
        cache: backendPluginApi.coreServices.cache
      },
      async init({ authProviders, cache }) {
        authProviders.registerProvider({
          providerId: "cfaccess",
          factory: pluginAuthNode.createProxyAuthProviderFactory({
            authenticator: createCloudflareAccessAuthenticator({ cache }),
            signInResolverFactories: {
              ...exports.cloudflareAccessSignInResolvers,
              ...pluginAuthNode.commonSignInResolvers
            }
          })
        });
      }
    });
  }
});

exports.createCloudflareAccessAuthenticator = createCloudflareAccessAuthenticator;
exports.default = authModuleCloudflareAccessProvider;
//# sourceMappingURL=index.cjs.js.map
