import { parseEntityRef, stringifyEntityRef } from '@backstage/catalog-model';
import qs from 'qs';
import { useMemo, useState, useCallback, useEffect } from 'react';
import { useLocation } from 'react-router-dom';
import usePrevious from 'react-use/esm/usePrevious';
import '../EntityRelationsGraph/EntityRelationsGraph.esm.js';
import { Direction } from '../EntityRelationsGraph/types.esm.js';

function useCatalogGraphPage({
  initialState = {}
}) {
  const location = useLocation();
  const query = useMemo(
    () => qs.parse(location.search, { arrayLimit: 0, ignoreQueryPrefix: true }) || {},
    [location.search]
  );
  const [rootEntityNames, setRootEntityNames] = useState(
    () => (Array.isArray(query.rootEntityRefs) ? query.rootEntityRefs : initialState?.rootEntityRefs ?? []).map((r) => parseEntityRef(r))
  );
  const [maxDepth, setMaxDepth] = useState(
    () => typeof query.maxDepth === "string" ? parseMaxDepth(query.maxDepth) : initialState?.maxDepth ?? Number.POSITIVE_INFINITY
  );
  const [selectedRelations, setSelectedRelations] = useState(
    () => Array.isArray(query.selectedRelations) ? query.selectedRelations : initialState?.selectedRelations
  );
  const [selectedKinds, setSelectedKinds] = useState(
    () => (Array.isArray(query.selectedKinds) ? query.selectedKinds : initialState?.selectedKinds)?.map((k) => k.toLocaleLowerCase("en-US"))
  );
  const [unidirectional, setUnidirectional] = useState(
    () => typeof query.unidirectional === "string" ? query.unidirectional === "true" : initialState?.unidirectional ?? true
  );
  const [mergeRelations, setMergeRelations] = useState(
    () => typeof query.mergeRelations === "string" ? query.mergeRelations === "true" : initialState?.mergeRelations ?? true
  );
  const [direction, setDirection] = useState(
    () => typeof query.direction === "string" ? query.direction : initialState?.direction ?? Direction.LEFT_RIGHT
  );
  const [curve, setCurve] = useState(
    () => typeof query.curve === "string" ? query.curve : initialState?.curve ?? "curveMonotoneX"
  );
  const [showFilters, setShowFilters] = useState(
    () => typeof query.showFilters === "string" ? query.showFilters === "true" : initialState?.showFilters ?? true
  );
  const toggleShowFilters = useCallback(
    () => setShowFilters((s) => !s),
    [setShowFilters]
  );
  const prevQueryParams = usePrevious(location.search);
  useEffect(() => {
    if (location.search === prevQueryParams) {
      return;
    }
    if (Array.isArray(query.rootEntityRefs)) {
      setRootEntityNames(query.rootEntityRefs.map((r) => parseEntityRef(r)));
    }
    if (typeof query.maxDepth === "string") {
      setMaxDepth(parseMaxDepth(query.maxDepth));
    }
    if (Array.isArray(query.selectedKinds)) {
      setSelectedKinds(query.selectedKinds);
    }
    if (Array.isArray(query.selectedRelations)) {
      setSelectedRelations(query.selectedRelations);
    }
    if (typeof query.unidirectional === "string") {
      setUnidirectional(query.unidirectional === "true");
    }
    if (typeof query.mergeRelations === "string") {
      setMergeRelations(query.mergeRelations === "true");
    }
    if (typeof query.direction === "string") {
      setDirection(query.direction);
    }
    if (typeof query.showFilters === "string") {
      setShowFilters(query.showFilters === "true");
    }
  }, [
    prevQueryParams,
    location.search,
    query,
    setRootEntityNames,
    setMaxDepth,
    setSelectedKinds,
    setSelectedRelations,
    setUnidirectional,
    setMergeRelations,
    setDirection,
    setShowFilters
  ]);
  const previousRootEntityRefs = usePrevious(
    rootEntityNames.map((e) => stringifyEntityRef(e))
  );
  useEffect(() => {
    const rootEntityRefs = rootEntityNames.map((e) => stringifyEntityRef(e));
    const newParams = qs.stringify(
      {
        rootEntityRefs,
        maxDepth: isFinite(maxDepth) ? maxDepth : "\u221E",
        selectedKinds,
        selectedRelations,
        unidirectional,
        mergeRelations,
        direction,
        showFilters
      },
      { arrayFormat: "brackets", addQueryPrefix: true }
    );
    const newUrl = `${window.location.pathname}${newParams}`;
    if (!previousRootEntityRefs || rootEntityRefs.length === previousRootEntityRefs.length && rootEntityRefs.every((v, i) => v === previousRootEntityRefs[i])) {
      window.history.replaceState(null, document.title, newUrl);
    } else {
      window.history.pushState(null, document.title, newUrl);
    }
  }, [
    rootEntityNames,
    maxDepth,
    selectedKinds,
    selectedRelations,
    unidirectional,
    mergeRelations,
    direction,
    showFilters,
    previousRootEntityRefs
  ]);
  return {
    rootEntityNames,
    setRootEntityNames,
    maxDepth,
    setMaxDepth,
    selectedRelations,
    setSelectedRelations,
    selectedKinds,
    setSelectedKinds,
    unidirectional,
    setUnidirectional,
    mergeRelations,
    setMergeRelations,
    direction,
    setDirection,
    curve,
    setCurve,
    showFilters,
    toggleShowFilters
  };
}
function parseMaxDepth(value) {
  return value === "\u221E" ? Number.POSITIVE_INFINITY : Number(value);
}

export { useCatalogGraphPage };
//# sourceMappingURL=useCatalogGraphPage.esm.js.map
